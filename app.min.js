

// Глобальные переменные
let currentTab = 'home';
let current = null;
let curIndex = 0;
let zoomed = false;
let tx = 0, ty = 0;
let currentHints = [];
let scrollPosition = 0; // Добавляем переменную для сохранения позиции скролла
let isDraggingModal = false; // Флаг для отслеживания перетаскивания модалки
let dragStartX = 0; // Начальная позиция перетаскивания

// DOM элементы
const $modal = document.getElementById('modal');
const $mTitle = document.getElementById('mTitle');
const $mPrice = document.getElementById('mPrice');
const $mDesc = document.getElementById('mDesc');
const $mMeta = document.getElementById('mMeta');
const $mLink = document.getElementById('desktopLink');
const $mStatus = document.getElementById('mStatus');

// Данные товаров
let products = [];

// Загрузка данных из products.json
async function loadProducts() {
  try {
    if (window.loadProductsWithCacheBust) {
      products = await window.loadProductsWithCacheBust();
    } else {
      const response = await fetch('products.json?v=' + new Date().getTime());
      products = await response.json();
    }
    
    // Преобразуем данные в нужный формат
    products = products.map(item => ({
      id: `product_${item.id}`,
      images: item.images.split('|').map(img => img.trim()),
      title: item.title,
      price: item.price,
      desc: item.desc,
      meta: item.meta,
      link: item.link,
      status: item.status,
      order: parseInt(item.order),
      section: item.section
    }));
    
    // Предзагружаем изображения для плавного переключения
    preloadImages();
    
    // Обновляем каталог после загрузки данных
    renderCatalog();
  } catch (error) {
    console.error('Error loading products:', error);
  }
}

// Предзагрузка изображений с оптимизацией для мобильных
function preloadImages() {
  // Приоритетная загрузка баннеров
  const bannerImages = ['img/bannerh.jpg', 'img/banner.jpg'];
  bannerImages.forEach(src => {
    const img = new Image();
    img.src = src;
  });
  
  // Для мобильных устройств предзагружаем только первые изображения продуктов
  if (window.innerWidth <= 768) {
    products.slice(0, 8).forEach(product => { // Первые 8 продуктов
      if (product.images[0]) {
        const img = new Image();
        img.src = `img/${product.images[0]}`;
      }
    });
  } else {
    // Для десктопа предзагружаем все изображения
    products.forEach(product => {
      product.images.forEach(image => {
        const img = new Image();
        img.src = `img/${image}`;
      });
    });
  }
}


// Инициализация
document.addEventListener('DOMContentLoaded', () => {
  try {
    // Очищаем класс modal-open при загрузке страницы
    document.body.classList.remove('modal-open');
    document.body.style.overflow = '';
    
    initTabs();
    initFilters();
    initCarePanel();
    initScrollHandler();
    loadProducts(); // Загружаем данные из products.json
    loadHero();
    
    // Инициализируем оптимизированную загрузку изображений
    initImageOptimization();
    
    // Принудительно исправляем стили кнопки
    setTimeout(() => {
      const ctaButtons = document.querySelectorAll('.cta, #desktopLink.cta, .mobile-modal .cta');
      ctaButtons.forEach(btn => {
        btn.style.borderRadius = '0';
        btn.style.webkitBorderRadius = '0';
        btn.style.mozBorderRadius = '0';
        btn.style.width = '100vw';
        btn.style.maxWidth = '100vw';
        btn.style.left = '0';
        btn.style.right = '0';
        btn.style.marginLeft = '0';
        btn.style.marginRight = '0';
      });
    }, 100);
    
  } catch (error) {
    console.error('Error during initialization:', error);
  }
});

// Функция оптимизации загрузки изображений
function initImageOptimization() {
  if (window.innerWidth <= 768) {
    // Для мобильных устройств используем Intersection Observer для приоритетной загрузки
    const imageObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          if (img.dataset.src) {
            img.src = img.dataset.src;
            img.removeAttribute('data-src');
            imageObserver.unobserve(img);
          }
        }
      });
    }, {
      rootMargin: '50px 0px' // Начинаем загружать за 50px до появления
    });
    
    // Наблюдаем за изображениями карточек
    document.addEventListener('DOMContentLoaded', () => {
      const cardImages = document.querySelectorAll('.card-img img[data-src]');
      cardImages.forEach(img => imageObserver.observe(img));
    });
  }
}

// Функция оптимизации изображений карточек
function initCardImageOptimization() {
  if (window.innerWidth <= 768) {
    const imageObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          if (img.dataset.src) {
            img.src = img.dataset.src;
            img.removeAttribute('data-src');
            imageObserver.unobserve(img);
            
            // Предзагружаем следующие изображения для плавности
            preloadNextImages(img);
          }
        }
      });
    }, {
      rootMargin: '150px 0px' // Начинаем загружать за 150px до появления
    });
    
    // Наблюдаем за изображениями карточек
    const cardImages = document.querySelectorAll('.card-img img[data-src]');
    cardImages.forEach(img => imageObserver.observe(img));
  }
}

// Функция предзагрузки следующих изображений
function preloadNextImages(currentImg) {
  const card = currentImg.closest('.card');
  if (!card) return;
  
  const currentCardIndex = Array.from(card.parentNode.children).indexOf(card);
  const nextCards = Array.from(card.parentNode.children).slice(currentCardIndex + 1, currentCardIndex + 3);
  
  nextCards.forEach(nextCard => {
    const nextImg = nextCard.querySelector('img[data-src]');
    if (nextImg && nextImg.dataset.src) {
      const preloadImg = new Image();
      preloadImg.src = nextImg.dataset.src;
    }
  });
}

// Функции для вкладок
function initTabs() {
  const tabs = document.querySelectorAll('.tab');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      const section = tab.dataset.tab;
      switchTab(section);
    });
  });
}

function switchTab(section) {
  currentTab = section;
  
  // Очищаем состояние модалок при переключении вкладок
  closeAllModals();
  
  // Обновляем активную вкладку
  document.querySelectorAll('.tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.tab === section);
  });
  
  // Прокручиваем страницу вверх только если не было открытой модалки
  if (scrollPosition === 0) {
    window.scrollTo({ 
      top: 0, 
      behavior: 'instant' // Мгновенная прокрутка без анимации
    });
  }
  
  // Обновляем баннер
  loadHero();
  
  // Быстрая фильтрация каталога
  filterCatalog('all');
  
  // Устанавливаем атрибут data-section для стилей
  document.body.setAttribute('data-section', section);
  
  // Показываем/скрываем панель ухода и кнопку руководства
  const carePanel = document.getElementById('carePanel');
  const careBtn = document.getElementById('careBtn');
  
  if (carePanel) {
    if (section === 'nessffo') {
      // На десктопе панель изначально скрыта, на мобильных - показана
      if (window.innerWidth > 768) {
        carePanel.style.display = 'none';
        carePanel.classList.remove('open');
      } else {
        carePanel.style.display = 'block';
        carePanel.classList.remove('collapsed');
      }
    } else {
      carePanel.style.display = 'none';
      carePanel.classList.remove('open');
    }
  }
  
  // Показываем/скрываем кнопку руководства
  if (careBtn) {
    if (section === 'nessffo' && window.innerWidth > 768) {
      careBtn.style.display = 'flex';
    } else {
      careBtn.style.display = 'none';
    }
  }
}

// Функции для фильтров
function initFilters() {
  const filters = document.querySelectorAll('.fbtn');
  filters.forEach(filter => {
    filter.addEventListener('click', () => {
      const filterType = filter.dataset.filter;
      applyFilter(filterType);
    });
  });
}

function applyFilter(filterType) {
  // Обновляем активный фильтр
  document.querySelectorAll('.fbtn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.filter === filterType);
  });
  
  // Быстрая фильтрация без пересоздания DOM
  filterCatalog(filterType);
}

// Новая функция для быстрой фильтрации
function filterCatalog(filterType = 'all') {
  const cards = document.querySelectorAll('.card');
  
  cards.forEach(card => {
    const itemId = card.dataset.id;
    const item = products.find(p => p.id === itemId);
    
    if (item) {
      let shouldShow = true;
      
      // Проверяем соответствие текущей вкладке
      if (item.section !== currentTab) {
        shouldShow = false;
      } else {
        // Проверяем фильтр по статусу
        if (filterType === 'stock' && item.status !== 'stock') {
          shouldShow = false;
        } else if (filterType === 'preorder' && item.status !== 'preorder') {
          shouldShow = false;
        }
      }
      
      // Показываем/скрываем карточку
      if (shouldShow) {
        card.style.display = 'block';
        card.style.opacity = '1';
        card.style.visibility = 'visible';
      } else {
        card.style.display = 'none';
        card.style.opacity = '0';
        card.style.visibility = 'hidden';
      }
    }
  });
}

// Функции для панели ухода
function initCarePanel() {
  const carePanel = document.getElementById('carePanel');
  const careBtn = document.getElementById('careBtn');
  
  if (carePanel) {
    // Обработчик для панели (сворачивание при клике на заголовок только на мобильных)
    const careTitle = carePanel.querySelector('h4');
    if (careTitle) {
      careTitle.addEventListener('click', () => {
        if (window.innerWidth <= 768) {
          // Только на мобильных
          carePanel.classList.toggle('collapsed');
        }
      });
    }
  }
  
  // Обработчик для кнопки руководства
  if (careBtn) {
    careBtn.addEventListener('click', () => {
      if (carePanel) {
        carePanel.classList.toggle('open');
      }
    });
  }
}

// Функции для баннера
function loadHero() {
  const hero = document.querySelector('.hero');
  if (hero) {
    const banner = currentTab === 'home' ? 'bannerh.jpg' : 'banner.jpg';
    hero.src = `img/${banner}`;
    hero.alt = currentTab === 'home' ? 'Главная страница' : 'Nessffo Collection';
    hero.style.opacity = '1';
    hero.style.visibility = 'visible';
  } else {
    console.error('Hero element not found');
  }
}

// Функции для каталога
function renderCatalog(filterType = 'all') {
  const catalog = document.getElementById('catalog');
  if (!catalog) return;
  
  // Создаем все карточки сразу для быстрой фильтрации с индексами
  const allCards = products.map((item, index) => createCard(item, index)).join('');
  catalog.innerHTML = allCards;
  
  // Добавляем обработчики событий
  addCardEventListeners();
  
  // Применяем фильтр
  filterCatalog(filterType);
  
  // Показываем каталог
  catalog.style.opacity = '1';
  catalog.style.visibility = 'visible';
  catalog.style.display = 'grid';
  
  // Инициализируем оптимизацию изображений после рендеринга
  if (window.innerWidth <= 768) {
    initCardImageOptimization();
  }
}

function createCard(item, index = 0) {
  const statusText = item.status === 'preorder' ? 'под заказ' : 'в наличии';
  const statusClass = item.status === 'preorder' ? 'pre' : 'in';
  
  // Форматируем цену с пробелами и символом рубля
  const priceText = item.price.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ') + ' ₽';
  
  // Оптимизация для мобильных устройств
  const isMobile = window.innerWidth <= 768;
  const imageSrc = `img/${item.images[0]}`;
  
  // Для первых 4 карточек на мобильных загружаем сразу, остальные лениво
  const shouldLoadImmediately = isMobile && index < 4;
  
  const imgAttributes = shouldLoadImmediately
    ? `src="${imageSrc}" loading="eager" fetchpriority="high"`
    : isMobile 
      ? `data-src="${imageSrc}" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'/%3E" loading="lazy"`
      : `src="${imageSrc}" loading="lazy"`;
  
  return `
    <div class="card" data-id="${item.id}">
      <div class="card-img">
        <img ${imgAttributes} alt="${item.title}">
      </div>
      <h3>${item.title}</h3>
      <div class="price">${priceText}</div>
      <div class="status ${statusClass}">${statusText}</div>
    </div>
  `;
}

function addCardEventListeners() {
  const cards = document.querySelectorAll('.card');
  cards.forEach(card => {
    const itemId = card.dataset.id;
    const item = products.find(p => p.id === itemId);
    
    if (item) {
      // Обработчик клика
      card.addEventListener('click', () => openModal(item, currentTab));
      
      // Эффект смены изображений при наведении (только для десктопа)
      if (window.innerWidth > 768) {
        const imgBox = card.querySelector('.card-img');
        const img = imgBox.querySelector('img');
        
        if (imgBox && img && item.images.length > 1) {
          let isHovering = false;
          let hoverRaf = 0;
          let currentHoverIndex = 0;
          
          const applyIdx = (idx) => {
            if (idx !== currentHoverIndex && idx < item.images.length) {
              currentHoverIndex = idx;
              img.src = `img/${item.images[idx]}`;
            }
          };
          
          imgBox.addEventListener('mouseenter', () => {
            isHovering = true;
          });
          
          imgBox.addEventListener('mousemove', e => {
            if (!isHovering) return;
            
            if (hoverRaf) {
              cancelAnimationFrame(hoverRaf);
            }
            
            hoverRaf = requestAnimationFrame(() => {
              hoverRaf = 0;
              const rect = imgBox.getBoundingClientRect();
              const ratio = (e.clientX - rect.left) / rect.width;
              const idx = Math.min(item.images.length - 1, Math.max(0, Math.floor(ratio * item.images.length)));
              if (idx !== currentHoverIndex) {
                applyIdx(idx);
              }
            });
          });
          
          imgBox.addEventListener('mouseout', () => {
            isHovering = false;
            if (hoverRaf) {
              cancelAnimationFrame(hoverRaf);
              hoverRaf = 0;
            }
            if (currentHoverIndex !== 0) {
              applyIdx(0);
            }
          });
          
          imgBox.addEventListener('mouseleave', () => {
            isHovering = false;
            if (hoverRaf) {
              cancelAnimationFrame(hoverRaf);
              hoverRaf = 0;
            }
            if (currentHoverIndex !== 0) {
              applyIdx(0);
            }
          });
        }
      }
    }
  });
}

// Функции для модального окна (десктоп)
function openModal(item, section) {
  // Проверяем размер экрана для определения мобильной/десктопной версии
  const isMobile = window.innerWidth <= 768;
  
  if (isMobile) {
    // Для мобильной версии открываем новую модалку
    openMobileModal(item, section);
  } else {
    // Для десктопной версии открываем обычную модалку
    openDesktopModal(item, section);
  }
}

function openDesktopModal(item, section) {
  current = item;
  curIndex = 0;
  
  // Заполняем информацию
  $mTitle.textContent = item.title;
  
  // Форматируем цену
  const priceText = item.price.replace(' ₽', '').replace(' р.', '').replace('р', '');
  const formattedPrice = priceText.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ') + ' ₽';
  
  // Создаем контейнер для цены и статуса
  $mPrice.innerHTML = '';
  const priceContainer = document.createElement('div');
  priceContainer.className = 'modal-price-container';
  priceContainer.style.display = 'flex';
  priceContainer.style.justifyContent = 'center';
  priceContainer.style.alignItems = 'center';
  priceContainer.style.gap = '12px';
  priceContainer.style.flexWrap = 'wrap';
  
  const priceElement = document.createElement('span');
  priceElement.className = 'price-text';
  priceElement.textContent = formattedPrice;
  priceContainer.appendChild(priceElement);
  
  // Добавляем статус
  if (item.status) {
    const statusElement = document.createElement('span');
    const cls = (item.status === 'preorder') ? 'pre' : 'in';
    statusElement.className = 'modal-status ' + cls;
    statusElement.textContent = (item.status === 'preorder') ? 'под заказ' : 'в наличии';
    priceContainer.appendChild(statusElement);
  }
  
  $mPrice.appendChild(priceContainer);
  
  $mDesc.textContent = item.desc;
  $mMeta.textContent = item.meta || '';
  $mLink.href = item.link;
  
  // Устанавливаем изображение
  setMainImage(item.images[0]);
  renderThumbnails(item.images);
  
  // Добавляем обработчики для десктопной версии
  setupDesktopModalHandlers();
  
  // Открываем модалку
  $modal.classList.add('open');
  document.body.style.overflow = 'hidden';
}

function setMainImage(src) {
  const viewerImg = document.getElementById('viewerImg');
  if (viewerImg) {
    viewerImg.src = `img/${src}`;
  }
  
  // Добавляем обработчики кликов для листания фото
  const viewer = document.querySelector('.viewer');
  if (viewer && current) {
    // Удаляем старые обработчики
    viewer.removeEventListener('click', handleViewerClick);
    // Добавляем новый обработчик
    viewer.addEventListener('click', handleViewerClick);
  }
}

function handleViewerClick(e) {
  if (!current || current.images.length <= 1) return;
  
  const rect = e.currentTarget.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const width = rect.width;
  
  // Если клик в левой трети - предыдущее фото
  if (x < width / 3) {
    curIndex = (curIndex - 1 + current.images.length) % current.images.length;
    setMainImage(current.images[curIndex]);
    updateThumbnails();
  }
  // Если клик в правой трети - следующее фото
  else if (x > (width * 2) / 3) {
    curIndex = (curIndex + 1) % current.images.length;
    setMainImage(current.images[curIndex]);
    updateThumbnails();
  }
}

function handleMobileViewerClick(e) {
  if (!current || current.images.length <= 1) return;
  
  const rect = e.currentTarget.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const width = rect.width;
  
  // Если клик в левой трети - предыдущее фото
  if (x < width / 3) {
    curIndex = (curIndex - 1 + current.images.length) % current.images.length;
    const mobileMainImg = document.getElementById('mobileMainImg');
    if (mobileMainImg) {
      mobileMainImg.src = `img/${current.images[curIndex]}`;
    }
  }
  // Если клик в правой трети - следующее фото
  else if (x > (width * 2) / 3) {
    curIndex = (curIndex + 1) % current.images.length;
    const mobileMainImg = document.getElementById('mobileMainImg');
    if (mobileMainImg) {
      mobileMainImg.src = `img/${current.images[curIndex]}`;
    }
  }
}

function handleMobileZoomClick(e) {
  if (!current || current.images.length <= 1) return;
  
  const rect = e.currentTarget.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const width = rect.width;
  
  // Если клик в левой трети - предыдущее фото
  if (x < width / 3) {
    curIndex = (curIndex - 1 + current.images.length) % current.images.length;
    const mobileMainImg = document.getElementById('mobileMainImg');
    const mobileZoomImg = document.getElementById('mobileZoomImg');
    if (mobileMainImg) {
      mobileMainImg.src = `img/${current.images[curIndex]}`;
    }
    if (mobileZoomImg) {
      mobileZoomImg.src = `img/${current.images[curIndex]}`;
    }
  }
  // Если клик в правой трети - следующее фото
  else if (x > (width * 2) / 3) {
    curIndex = (curIndex + 1) % current.images.length;
    const mobileMainImg = document.getElementById('mobileMainImg');
    const mobileZoomImg = document.getElementById('mobileZoomImg');
    if (mobileMainImg) {
      mobileMainImg.src = `img/${current.images[curIndex]}`;
    }
    if (mobileZoomImg) {
      mobileZoomImg.src = `img/${current.images[curIndex]}`;
    }
  }
}

function renderThumbnails(images) {
  const thumbs = document.getElementById('thumbs');
  if (!thumbs) return;
  
  thumbs.innerHTML = '';
  images.forEach((imagePath, idx) => {
    const thumb = document.createElement('img');
    thumb.src = `img/${imagePath}`;
    thumb.alt = '';
    thumb.className = `thumb ${idx === 0 ? 'active' : ''}`;
    thumb.addEventListener('click', () => {
      curIndex = idx;
      setMainImage(imagePath);
      updateThumbnails();
    });
    thumbs.appendChild(thumb);
  });
}

function updateThumbnails() {
  const thumbs = document.querySelectorAll('#thumbs .thumb');
  thumbs.forEach((thumb, idx) => {
    thumb.classList.toggle('active', idx === curIndex);
  });
}

function closeModal() {
  $modal.classList.remove('open');
  document.body.style.overflow = '';
}

// Обработчики событий для десктопной модалки
if ($modal) {
  $modal.addEventListener('click', closeModal);
}

const closeBtn = document.getElementById('closeBtn');
if (closeBtn) {
  closeBtn.addEventListener('click', closeModal);
}

// ===== ФУНКЦИИ ДЛЯ МОБИЛЬНОЙ МОДАЛКИ =====
function openMobileModal(item, section) {
  current = item;
  curIndex = 0;
  
  // Кэшируем DOM элементы для оптимизации
  const mobileModal = document.getElementById('mobileModal');
  const mobileTitle = document.getElementById('mobileTitle');
  const mobilePrice = document.getElementById('mobilePrice');
  const mobileDesc = document.getElementById('mobileDesc');
  const mobileMainImg = document.getElementById('mobileMainImg');
  const mobileDots = document.getElementById('mobileDots');
  const mobileLink = document.getElementById('mobileLink');
  
  if (!mobileModal || !mobileTitle || !mobilePrice || !mobileDesc || !mobileMainImg || !mobileLink) {
    console.error('Не найдены элементы мобильной модалки');
    return;
  }
  
  // Заполняем информацию о товаре
  mobileTitle.textContent = item.title;
  
  // Форматируем цену и добавляем статус
  const priceText = item.price.replace(' ₽', '').replace(' р.', '').replace('р', '');
  const formattedPrice = priceText.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ') + ' ₽';
  
  // Очищаем контейнер цены
  mobilePrice.innerHTML = '';
  
  // Добавляем цену
  const priceElement = document.createElement('span');
  priceElement.textContent = formattedPrice;
  priceElement.className = 'mobile-price-text';
  mobilePrice.appendChild(priceElement);
  
  // Добавляем статус рядом с ценой
    if (item.status) {
    const statusElement = document.createElement('span');
    const statusLabel = (item.status === 'preorder') ? 'под заказ' : 'в наличии';
    statusElement.textContent = ' ' + statusLabel;
    statusElement.style.marginLeft = '8px';
    statusElement.style.padding = '2px 6px';
    statusElement.style.borderRadius = '4px';
    statusElement.style.fontSize = '12px';
    statusElement.style.fontWeight = '500';
    statusElement.style.color = item.status === 'preorder' ? '#92400e' : '#065f46';
    statusElement.style.backgroundColor = item.status === 'preorder' ? '#fef3c7' : '#f0fdf4';
    statusElement.style.opacity = '0.8';
    statusElement.style.verticalAlign = 'middle';
    statusElement.style.display = 'inline-block';
    mobilePrice.appendChild(statusElement);
  }
  
  mobileDesc.textContent = item.desc;
  
  // Настройка кнопки "Состав" - только клик
  const mobileCompositionBtn = document.getElementById('mobileCompositionBtn');
  if (mobileCompositionBtn) {
    // Сбрасываем состояние кнопки
    mobileCompositionBtn.classList.remove('active');
    mobileCompositionBtn.textContent = '?';
    
    // Удаляем ВСЕ возможные обработчики
    mobileCompositionBtn.removeEventListener('click', mobileCompositionBtn._clickHandler);
    
    // Создаем новый обработчик только для клика
    mobileCompositionBtn._clickHandler = function(e) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      
      // Мгновенное переключение
      if (this.classList.contains('active')) {
        // Показываем описание
        this.classList.remove('active');
        this.textContent = '?';
        mobileDesc.textContent = item.desc;
      } else {
        // Показываем состав
        this.classList.add('active');
        this.textContent = '?';
        mobileDesc.textContent = item.meta;
      }
    };
    
    // Добавляем только обработчик клика с высоким приоритетом
    mobileCompositionBtn.addEventListener('click', mobileCompositionBtn._clickHandler, { capture: true });
  }
  

  mobileLink.href = item.link;
  
  // Устанавливаем первое изображение
  mobileMainImg.src = `img/${item.images[0]}`;
  mobileMainImg.alt = item.title;
  
  // Показываем счетчик изображений в левом верхнем углу
  if (mobileDots && item.images.length > 1) {
    mobileDots.style.display = 'flex';
    mobileDots.style.justifyContent = 'center';
    mobileDots.style.alignItems = 'center';
    mobileDots.style.position = 'absolute';
    mobileDots.style.top = '16px';
    mobileDots.style.left = '16px';
    mobileDots.style.background = 'rgba(0, 0, 0, 0.5)';
    mobileDots.style.color = 'white';
    mobileDots.style.padding = '4px 8px';
    mobileDots.style.borderRadius = '8px';
    mobileDots.style.fontSize = '12px';
    mobileDots.style.fontWeight = '500';
    mobileDots.style.zIndex = '5';
    mobileDots.style.pointerEvents = 'none'; // Не блокирует свайпы
    mobileDots.style.width = 'auto';
    mobileDots.style.height = 'auto';
    mobileDots.style.textAlign = 'center';
    mobileDots.innerHTML = `1 / ${item.images.length}`;
  } else if (mobileDots) {
    mobileDots.style.display = 'none';
    mobileDots.innerHTML = '';
  }
  
  // ОЧИЩАЕМ ВСЕ СТАРЫЕ ОБРАБОТЧИКИ ПЕРЕД ДОБАВЛЕНИЕМ НОВЫХ
  const mobileMainImage = document.querySelector('.mobile-main-image');
  const mobileModalElement = document.getElementById('mobileModal');
  
  if (mobileMainImage) {
    // Удаляем все старые обработчики
    mobileMainImage.removeEventListener('click', handleMobileViewerClick);
    mobileMainImage.removeEventListener('click', openMobileZoom);
    mobileMainImage.removeEventListener('touchstart', mobileMainImage._touchStartHandler);
    mobileMainImage.removeEventListener('touchmove', mobileMainImage._touchMoveHandler);
    mobileMainImage.removeEventListener('touchend', mobileMainImage._touchEndHandler);
    
    // Добавляем обработчик клика для зума
    mobileMainImage.addEventListener('click', (e) => {
      // Проверяем, что клик не по кнопке закрытия
      if (e.target.closest('.mobile-close-btn')) {
        return; // Не открываем зум если клик по крестику
      }
      openMobileZoom(e);
    });
  }
  
  if (mobileModalElement) {
    // Удаляем старые обработчики свайпа закрытия
    mobileModalElement.removeEventListener('touchstart', mobileModalElement._swipeCloseTouchStart);
    mobileModalElement.removeEventListener('touchmove', mobileModalElement._swipeCloseTouchMove);
    mobileModalElement.removeEventListener('touchend', mobileModalElement._swipeCloseTouchEnd);
    
    // Добавляем обработчик свайпа закрытия на весь контейнер модалки
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    let isDraggingModal = false;
    let dragStartX = 0;
    
    mobileModalElement._swipeCloseTouchStart = (e) => {
        if (e.touches.length === 1) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          touchStartTime = Date.now();
          
          // Если свайп начинается с левого края экрана, включаем режим перетаскивания
          if (touchStartX < 50) {
            isDraggingModal = true;
            dragStartX = touchStartX;
          }
        }
      };
      
      mobileModalElement._swipeCloseTouchMove = (e) => {
        if (e.touches.length === 1 && isDraggingModal && touchStartX < 50) {
          const touchX = e.touches[0].clientX;
          const dragDeltaX = touchX - dragStartX;
          
          if (dragDeltaX > 0) {
            // Применяем визуальный эффект сдвига
            const translateX = Math.min(dragDeltaX, window.innerWidth);
            mobileModalElement.style.transform = `translateX(${translateX}px)`;
            mobileModalElement.style.transition = 'none';
            
            // Добавляем затемнение при перетаскивании
            const overlay = mobileModalElement.querySelector('.mobile-modal-content');
            if (overlay) {
              const opacity = Math.max(0.3, 1 - (dragDeltaX / window.innerWidth) * 0.7);
              overlay.style.opacity = opacity;
            }
          }
        }
      };
      
      mobileModalElement._swipeCloseTouchEnd = (e) => {
        if (e.changedTouches.length === 1 && isDraggingModal && touchStartX < 50) {
          const touchEndX = e.changedTouches[0].clientX;
          const dragDeltaX = touchEndX - dragStartX;
          
          if (dragDeltaX > 100) {
            // Закрываем модалку с анимацией
            mobileModalElement.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            mobileModalElement.style.transform = `translateX(${window.innerWidth}px)`;
            const overlay = mobileModalElement.querySelector('.mobile-modal-content');
            if (overlay) {
              overlay.style.transition = 'opacity 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
              overlay.style.opacity = '0';
            }
            setTimeout(() => {
              closeAllModals();
              // Сбрасываем стили
              mobileModalElement.style.transform = '';
              mobileModalElement.style.transition = '';
              if (overlay) {
                overlay.style.opacity = '';
                overlay.style.transition = '';
              }
            }, 400);
          } else {
            // Возвращаем модалку на место с пружинной анимацией
            mobileModalElement.style.transition = 'transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
            mobileModalElement.style.transform = '';
            const overlay = mobileModalElement.querySelector('.mobile-modal-content');
            if (overlay) {
              overlay.style.transition = 'opacity 0.3s ease-out';
              overlay.style.opacity = '1';
            }
            setTimeout(() => {
              mobileModalElement.style.transition = '';
              if (overlay) {
                overlay.style.transition = '';
              }
            }, 300);
          }
          isDraggingModal = false;
        }
      };
      
      // Добавляем обработчики
      mobileModalElement.addEventListener('touchstart', mobileModalElement._swipeCloseTouchStart, { passive: true });
      mobileModalElement.addEventListener('touchmove', mobileModalElement._swipeCloseTouchMove, { passive: true });
      mobileModalElement.addEventListener('touchend', mobileModalElement._swipeCloseTouchEnd, { passive: false });
    }
    
    // НОВАЯ ЛОГИКА: Обработчики для листания изображений в основной модалке
    if (current && current.images.length > 1) {
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartTime = 0;
      let isSwiping = false;
      
      // Сохраняем ссылки на функции для возможности удаления
      mobileMainImage._touchStartHandler = (e) => {
        if (e.touches.length === 1) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          isSwiping = false;
        }
      };
      
      mobileMainImage._touchMoveHandler = (e) => {
        if (e.touches.length === 1) {
          const currentX = e.touches[0].clientX;
          const currentY = e.touches[0].clientY;
          const deltaX = Math.abs(currentX - touchStartX);
          const deltaY = Math.abs(currentY - touchStartY);
          
          // Ультра-быстрое определение горизонтального свайпа для iPhone
          if (deltaX > 1 && deltaX > deltaY) {
            isSwiping = true;
          }
        }
      };
      
      mobileMainImage._touchEndHandler = (e) => {
        if (e.changedTouches.length === 1 && isSwiping) {
          const touchEndX = e.changedTouches[0].clientX;
          const deltaX = touchStartX - touchEndX;
          
          // Ультра-быстрые условия для iPhone
          if (Math.abs(deltaX) > 5) {
            if (deltaX > 0) {
              curIndex = (curIndex + 1) % current.images.length;
            } else {
              curIndex = (curIndex - 1 + current.images.length) % current.images.length;
            }
            
            // Мгновенное обновление изображения без задержек
            const mobileMainImg = document.getElementById('mobileMainImg');
            if (mobileMainImg) {
              // Принудительно обновляем счетчик сразу
              updateMobileImageCounter();
              updateZoomDots();
              // Мгновенно меняем изображение
              mobileMainImg.src = `img/${current.images[curIndex]}`;
            }
          }
        }
      };
      
      // Добавляем обработчики для максимальной скорости на iPhone
      mobileMainImage.addEventListener('touchstart', mobileMainImage._touchStartHandler, { passive: true });
      mobileMainImage.addEventListener('touchmove', mobileMainImage._touchMoveHandler, { passive: true });
      mobileMainImage.addEventListener('touchend', mobileMainImage._touchEndHandler, { passive: false });
  }
  
  // ОЧИЩАЕМ состояние зум модалки при открытии новой карточки
  const mobileZoomModal = document.getElementById('mobileZoomModal');
  const mobileZoomImg = document.getElementById('mobileZoomImg');
  if (mobileZoomModal) {
    mobileZoomModal.classList.remove('open');
  }
  if (mobileZoomImg) {
    mobileZoomImg.style.transform = 'scale(1) translate(0, 0)';
    mobileZoomImg.style.transformOrigin = 'center center';
  }
  
  // Открываем модалку
  mobileModalElement.classList.add('open');
  scrollPosition = window.pageYOffset; // Сохраняем позицию скролла
  document.body.style.overflow = 'hidden';
  document.body.classList.add('modal-open'); // Добавляем класс для блокировки каталога
  
  // Добавляем обработчики событий
  addMobileEventHandlers();
  
  // Принудительно предзагружаем изображения для быстрого листания
  if (current && current.images.length > 1) {
    // Мгновенно предзагружаем все изображения
    current.images.forEach(image => {
      const img = new Image();
      img.src = `img/${image}`;
    });
  }
}

function updateMobileImageCounter() {
  const mobileDots = document.getElementById('mobileDots');
  if (mobileDots && current && current.images.length > 1) {
    // Используем textContent вместо innerHTML для скорости
    mobileDots.textContent = `${curIndex + 1} / ${current.images.length}`;
  }
}

function closeMobileModal() {
  closeAllModals();
}

function closeMobileModalWithAnimation() {
  // Мгновенное закрытие без анимации
  closeAllModals();
}

function addMobileEventHandlers() {
  const mobileCloseBtn = document.getElementById('mobileCloseBtn');
  const mobileModal = document.getElementById('mobileModal');
  const mobileInfoBlock = document.querySelector('.mobile-info-block');
  
  if (mobileCloseBtn) {
    mobileCloseBtn.removeEventListener('click', closeMobileModal);
    mobileCloseBtn.addEventListener('click', (e) => {
      closeMobileModal();
    });
  }
  
  // Добавляем обработчик жеста "назад" для основной модалки
  if (mobileModal) {
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    
    mobileModal.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
      }
    }, { passive: true });
    
    mobileModal.addEventListener('touchend', (e) => {
      if (e.changedTouches.length === 1) {
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const touchEndTime = Date.now();
        
        const deltaX = touchEndX - touchStartX; // Обратное направление для жеста "назад"
        const deltaY = Math.abs(touchEndY - touchStartY);
        const deltaTime = touchEndTime - touchStartTime;
        
        // Жест "назад" в Safari: свайп справа налево с левого края экрана
        if (deltaX > 100 && deltaTime > 300 && deltaY < 50 && touchStartX < 50) {

          closeMobileModalWithAnimation();
          return;
        }
      }
    }, { passive: false });
  }
  
  // УБИРАЕМ обработчик клавиши Escape - модалка закрывается только свайпом и крестиком
  // document.addEventListener('keydown', (e) => {
  //   if (e.key === 'Escape') {
  //     closeAllModals();
  //   }
  // });
  
  // Убираем блокирующие обработчики для текстового блока и кнопки CTA
  // Они мешают жесту "назад" и листанию изображений
  // Теперь все свайпы обрабатываются централизованно
}

function removeMobileEventHandlers() {
  const mobileCloseBtn = document.getElementById('mobileCloseBtn');
  const mobileZoomBtn = document.getElementById('mobileZoomBtn');
  const mobileModal = document.getElementById('mobileModal');
  
  if (mobileCloseBtn) {
    mobileCloseBtn.removeEventListener('click', closeMobileModal);
  }
  
  if (mobileZoomBtn) {
    mobileZoomBtn.removeEventListener('click', openMobileZoom);
  }
  
  if (mobileModal) {
    // Убираем обработчики закрытия по клику на фон
    // mobileModal.removeEventListener('click', (e) => {
    //   if (e.target === mobileModal) closeMobileModal();
    // });
  }
}

// ===== ФУНКЦИИ ДЛЯ ЗУМА В МОБИЛЬНОЙ МОДАЛКЕ =====
function openMobileZoom() {
  const mobileZoomModal = document.getElementById('mobileZoomModal');
  const mobileZoomImg = document.getElementById('mobileZoomImg');
  const mobileMainImg = document.getElementById('mobileMainImg');
  
  if (!mobileZoomModal || !mobileZoomImg || !mobileMainImg) return;
  
  // Копируем текущее изображение в зум модалку
  mobileZoomImg.src = mobileMainImg.src;
  mobileZoomImg.alt = '';
  
  // Убираем закругления
  mobileZoomImg.style.borderRadius = '0';
  
  // Показываем счетчик в зум режиме в левом верхнем углу
  const zoomDotsContainer = document.getElementById('mobileZoomDots');
  if (zoomDotsContainer && current && current.images.length > 1) {
    zoomDotsContainer.style.display = 'flex';
    zoomDotsContainer.style.justifyContent = 'center';
    zoomDotsContainer.style.alignItems = 'center';
    zoomDotsContainer.style.position = 'absolute';
    zoomDotsContainer.style.top = '16px';
    zoomDotsContainer.style.left = '16px';
    zoomDotsContainer.style.background = 'rgba(0, 0, 0, 0.5)';
    zoomDotsContainer.style.color = 'white';
    zoomDotsContainer.style.padding = '4px 8px';
    zoomDotsContainer.style.borderRadius = '8px';
    zoomDotsContainer.style.fontSize = '12px';
    zoomDotsContainer.style.fontWeight = '500';
    zoomDotsContainer.style.zIndex = '5';
    zoomDotsContainer.style.pointerEvents = 'none'; // Не блокирует свайпы
    zoomDotsContainer.style.width = 'auto';
    zoomDotsContainer.style.height = 'auto';
    zoomDotsContainer.style.textAlign = 'center';
    zoomDotsContainer.innerHTML = `${curIndex + 1} / ${current.images.length}`;
  } else if (zoomDotsContainer) {
    zoomDotsContainer.style.display = 'none';
    zoomDotsContainer.innerHTML = '';
  }
  
  mobileZoomModal.classList.add('open');
  document.body.style.overflow = 'hidden';
  addMobileZoomEventHandlers();
  
  // Убираем клики для листания в зум-версии - только свайпы
  const mobileZoomContent = document.querySelector('.mobile-zoom-content');
  if (mobileZoomContent) {
    // Убираем блокирующие обработчики - они мешают жесту "назад" и листанию
    // Обработчики свайпов теперь в addMobileZoomEventHandlers()
  }
}

function updateZoomDots() {
  const zoomDotsContainer = document.getElementById('mobileZoomDots');
  if (zoomDotsContainer && current && current.images.length > 1) {
    // Используем textContent вместо innerHTML для скорости
    zoomDotsContainer.textContent = `${curIndex + 1} / ${current.images.length}`;
  }
}

function closeMobileZoom() {
  const mobileZoomModal = document.getElementById('mobileZoomModal');
  if (mobileZoomModal) {
    mobileZoomModal.classList.remove('open');
    // Возвращаемся в обычную модалку, не закрываем все
    document.body.style.overflow = 'hidden';
    
    // Очищаем обработчики зум модалки
    const mobileZoomImg = document.getElementById('mobileZoomImg');
    const mobileZoomCloseBtn = document.getElementById('mobileZoomCloseBtn');
    
    if (mobileZoomImg) {
      mobileZoomImg.removeEventListener('touchstart', mobileZoomImg._swipeTouchStart);
      mobileZoomImg.removeEventListener('touchmove', mobileZoomImg._swipeTouchMove);
      mobileZoomImg.removeEventListener('touchend', mobileZoomImg._swipeTouchEnd);
      mobileZoomImg.removeEventListener('gestureend', mobileZoomImg._gestureEnd);
      mobileZoomImg.removeEventListener('click', mobileZoomImg._clickHandler);
    }
    
    if (mobileZoomCloseBtn) {
      mobileZoomCloseBtn.removeEventListener('click', closeMobileZoom);
    }
    
    if (mobileZoomModal) {
      mobileZoomModal.removeEventListener('touchstart', mobileZoomModal._backGestureTouchStart);
      mobileZoomModal.removeEventListener('touchend', mobileZoomModal._backGestureTouchEnd);
    }
  }
}

function addMobileZoomEventHandlers() {
  const mobileZoomCloseBtn = document.getElementById('mobileZoomCloseBtn');
  const mobileZoomImg = document.getElementById('mobileZoomImg');
  const mobileZoomModal = document.getElementById('mobileZoomModal');
  
  // ОЧИЩАЕМ ВСЕ СТАРЫЕ ОБРАБОТЧИКИ ПЕРЕД ДОБАВЛЕНИЕМ НОВЫХ
  if (mobileZoomCloseBtn) {
    mobileZoomCloseBtn.removeEventListener('click', closeMobileZoom);
    mobileZoomCloseBtn.addEventListener('click', closeMobileZoom);
  }
  
  if (mobileZoomModal) {
    // Удаляем старые обработчики жеста "назад"
    mobileZoomModal.removeEventListener('touchstart', mobileZoomModal._backGestureTouchStart);
    mobileZoomModal.removeEventListener('touchend', mobileZoomModal._backGestureTouchEnd);
  }
  
  if (mobileZoomImg) {
    // Удаляем старые обработчики свайпов
    mobileZoomImg.removeEventListener('touchstart', mobileZoomImg._swipeTouchStart);
    mobileZoomImg.removeEventListener('touchmove', mobileZoomImg._swipeTouchMove);
    mobileZoomImg.removeEventListener('touchend', mobileZoomImg._swipeTouchEnd);
    mobileZoomImg.removeEventListener('gestureend', mobileZoomImg._gestureEnd);
    mobileZoomImg.removeEventListener('click', mobileZoomImg._clickHandler);
  }
  
  // Добавляем обработчик на весь экран для перехвата жеста "назад"
  if (mobileZoomModal) {
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    
    mobileZoomModal._backGestureTouchStart = (e) => {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
      }
    };
    
    mobileZoomModal._backGestureTouchEnd = (e) => {
      if (e.changedTouches.length === 1) {
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const touchEndTime = Date.now();
        
        const deltaX = touchEndX - touchStartX; // Обратное направление для жеста "назад"
        const deltaY = touchEndY - touchStartY; // Убираем Math.abs для определения направления
        const deltaTime = touchEndTime - touchStartTime;
        
        // Проверяем, не находимся ли мы в зум состоянии
        const mobileZoomImg = document.getElementById('mobileZoomImg');
        if (mobileZoomImg) {
          const transform = window.getComputedStyle(mobileZoomImg).transform;
          const matrix = new DOMMatrix(transform);
          const currentScale = matrix.a;
          
          // Если изображение увеличено - НЕ закрываем модалку жестом "назад"
          if (currentScale > 1.02) {
            return;
          }
        }
        
        // Жест "назад" в Safari: только горизонтальный свайп справа налево с левого края экрана
        // Блокируем выход движением влево-вниз
        if (deltaX > 100 && deltaTime > 300 && Math.abs(deltaY) < 30 && touchStartX < 50) {
          closeMobileZoom();
          return;
        }
      }
    };
    
    mobileZoomModal.addEventListener('touchstart', mobileZoomModal._backGestureTouchStart, { passive: true });
    mobileZoomModal.addEventListener('touchend', mobileZoomModal._backGestureTouchEnd, { passive: false });
    
    // Блокируем листание на уровне всей зум модалки
    mobileZoomModal.addEventListener('touchmove', (e) => {
      const mobileZoomImg = document.getElementById('mobileZoomImg');
      if (mobileZoomImg) {
        const transform = window.getComputedStyle(mobileZoomImg).transform;
        const matrix = new DOMMatrix(transform);
        const currentScale = matrix.a;
        if (currentScale > 1.02) {
          e.preventDefault();
          e.stopPropagation();
        }
      }
    }, { passive: false });
  }
  
  if (mobileZoomImg) {
    // УМНАЯ ЛОГИКА ЗУМА: Различаем состояния зума
    if (current && current.images.length > 1) {
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartTime = 0;
      let isSwiping = false;
      let isZoomed = false; // Флаг для отслеживания состояния зума
      
      // Функция для безопасного определения масштаба
      function getCurrentScale(element) {
        try {
          const transform = window.getComputedStyle(element).transform;
          console.log('Raw transform:', transform); // Отладка
          
          if (transform && transform !== 'none') {
            const matrix = new DOMMatrix(transform);
            const scale = matrix.a;
            console.log('DOMMatrix scale:', scale); // Отладка
            return scale;
          }
        } catch (error) {
          console.log('DOMMatrix error:', error); // Отладка
          // Альтернативный способ через CSS
          const transform = window.getComputedStyle(element).transform;
          if (transform && transform.includes('scale(')) {
            const scaleMatch = transform.match(/scale\(([^)]+)\)/);
            if (scaleMatch) {
              const scale = parseFloat(scaleMatch[1]);
              console.log('CSS scale:', scale); // Отладка
              return scale;
            }
          }
        }
        
        // Дополнительная проверка через другие свойства
        const zoom = window.getComputedStyle(element).zoom;
        if (zoom && zoom !== 'normal') {
          const scale = parseFloat(zoom);
          console.log('CSS zoom:', scale); // Отладка
          return scale;
        }
        
        console.log('Default scale: 1'); // Отладка
        return 1;
      }
      
      // Функция для определения зума через viewport и другие способы
      function isImageZoomed(element) {
        // Способ 1: Через viewport scale
        const viewportScale = window.visualViewport ? window.visualViewport.scale : 1;
        console.log('Viewport scale:', viewportScale);
        
        // Способ 2: Через размеры изображения (исправленный)
        const naturalWidth = element.naturalWidth;
        const naturalHeight = element.naturalHeight;
        const displayWidth = element.offsetWidth;
        const displayHeight = element.offsetHeight;
        
        // Проверяем, что изображение загружено
        if (naturalWidth > 0 && naturalHeight > 0) {
          const scaleByWidth = displayWidth / naturalWidth;
          const scaleByHeight = displayHeight / naturalHeight;
          const scaleBySize = Math.max(scaleByWidth, scaleByHeight);
          console.log('Scale by size - Width:', scaleByWidth, 'Height:', scaleByHeight, 'Max:', scaleBySize);
          
          // Если изображение увеличено относительно контейнера
          if (scaleBySize > 1.1) {
            console.log('Image is zoomed by size');
            return true;
          }
        }
        
        // Способ 3: Через viewport scale
        if (viewportScale > 1.01) {
          console.log('Viewport is zoomed');
          return true;
        }
        
        // Способ 4: Через CSS transform scale
        const transform = window.getComputedStyle(element).transform;
        if (transform && transform !== 'none' && transform !== 'matrix(1, 0, 0, 1, 0, 0)') {
          console.log('Transform indicates zoom');
          return true;
        }
        
        console.log('No zoom detected');
        return false;
      }
      
      // Функция для показа отладочной информации на экране
      function showDebugInfo(event, scale, isZoomed) {
        let debugElement = document.getElementById('debug-info');
        if (!debugElement) {
          debugElement = document.createElement('div');
          debugElement.id = 'debug-info';
          debugElement.style.cssText = `
            position: fixed;
            top: 50px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            z-index: 9999;
            pointer-events: none;
          `;
          document.body.appendChild(debugElement);
        }
        
        debugElement.innerHTML = `
          <div>Event: ${event}</div>
          <div>Scale: ${scale.toFixed(3)}</div>
          <div>Zoomed: ${isZoomed}</div>
          <div>Time: ${new Date().toLocaleTimeString()}</div>
        `;
        
        // Автоматически скрываем через 2 секунды
        setTimeout(() => {
          if (debugElement) {
            debugElement.style.opacity = '0.5';
          }
        }, 2000);
      }
      
      mobileZoomImg._swipeTouchStart = (e) => {
        // СРАЗУ проверяем состояние зума с новым способом
        let isZoomedNow = isImageZoomed(mobileZoomImg);
        
        // Дополнительная проверка через viewport scale
        const viewportScale = window.visualViewport ? window.visualViewport.scale : 1;
        if (viewportScale > 1.01) {
          isZoomedNow = true;
          console.log('Forced zoom detection via viewport scale:', viewportScale);
        }
        
        // Отладочная информация
        console.log('TouchStart - isZoomed:', isZoomedNow, 'ViewportScale:', viewportScale);
        
        // Визуальный индикатор на экране
        showDebugInfo('TouchStart', isZoomedNow ? 2 : 1, isZoomedNow);
        
        // ВСЕГДА устанавливаем координаты начала касания (нужно для панорамирования)
        if (e.touches.length === 1) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          touchStartTime = Date.now();
        }
        
        // Если в зуме - только сбрасываем флаг свайпа, разрешаем панорамирование
        if (isZoomedNow) {
          isSwiping = false;
          console.log('TouchStart в зум режиме - разрешаем панорамирование');
          // НЕ блокируем touchstart - разрешаем браузеру обрабатывать панорамирование
          // НЕ делаем return - пусть событие продолжает обрабатываться
        }
        
        // Если НЕ в зуме - сбрасываем флаг свайпа
        isSwiping = false;
      };
      
      mobileZoomImg._swipeTouchMove = (e) => {
        if (e.touches.length === 1) {
          // ВСЕГДА проверяем состояние зума при каждом движении с новым способом
          let isZoomedNow = isImageZoomed(mobileZoomImg);
          
          // Дополнительная проверка через viewport scale
          const viewportScale = window.visualViewport ? window.visualViewport.scale : 1;
          if (viewportScale > 1.01) {
            isZoomedNow = true;
            console.log('Forced zoom detection via viewport scale:', viewportScale);
          }
          
          // Отладочная информация
          console.log('TouchMove - isZoomed:', isZoomedNow, 'ViewportScale:', viewportScale);
          
          // Визуальный индикатор на экране
          showDebugInfo('TouchMove', isZoomedNow ? 2 : 1, isZoomedNow);
          
          // Если в зуме - разрешаем ВСЕ движения для панорамирования
          if (isZoomedNow) {
            isSwiping = false;
            isZoomed = true; // Обновляем глобальный флаг
            
            // В зум режиме разрешаем ВСЕ движения - пользователь должен мочь панорамировать
            // НЕ блокируем никакие движения
            console.log('TouchMove в зум режиме - разрешаем панорамирование');
            // НЕ делаем return - пусть браузер обрабатывает панорамирование
          }
          
          const currentX = e.touches[0].clientX;
          const currentY = e.touches[0].clientY;
          const deltaX = Math.abs(currentX - touchStartX);
          const deltaY = Math.abs(currentY - touchStartY);
          
          // Если НЕ в зуме - блокируем вертикальные движения
          if (deltaY > 5) {
            e.preventDefault();
            e.stopPropagation();
            return;
          }
          
          // Если НЕ в зуме - определяем горизонтальный свайп для листания
          if (deltaX > 10 && deltaX > deltaY) {
            isSwiping = true;
          }
        }
      };
      
      // Обработчик для сброса положения при слишком далеком отдалении
      mobileZoomImg._gestureEnd = (e) => {
        const currentScale = getCurrentScale(mobileZoomImg);
        
        // Отладочная информация
        console.log('GestureEnd - Scale:', currentScale);
        
        // Если масштаб меньше 0.5 (слишком далеко отдалили), сбрасываем положение
        if (currentScale < 0.5) {
          mobileZoomImg.style.transform = 'scale(1) translate(0, 0)';
          mobileZoomImg.style.transformOrigin = 'center center';
          isZoomed = false;
          isSwiping = false; // Сбрасываем флаг свайпа
          // Больше не используем CSS класс для блокировки
          // НЕ закрываем модалку при отдалении!
        }
        
        // Если масштаб больше 1.01 - обновляем флаг зума
        if (currentScale > 1.01) {
          isZoomed = true;
          isSwiping = false; // Принудительно сбрасываем флаг свайпа
          // Больше не используем CSS класс для блокировки
        }
        
        // Если масштаб больше 3.0 (сильное приближение) - ограничиваем
        if (currentScale > 3.0) {
          mobileZoomImg.style.transform = 'scale(3) translate(0, 0)';
          mobileZoomImg.style.transformOrigin = 'center center';
          isZoomed = true;
        }
      };
      
      // Клик для выхода из зума (если увеличен) или закрытия модалки (если не увеличен)
      mobileZoomImg._clickHandler = (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        // Проверяем текущее состояние зума
        const transform = window.getComputedStyle(mobileZoomImg).transform;
        const matrix = new DOMMatrix(transform);
        const currentScale = matrix.a;
        let isCurrentlyZoomed = currentScale > 1.01; // Уменьшаем порог для более стабильного определения зума
        
        if (isCurrentlyZoomed) {
          // Если увеличен - возвращаем к нормальному размеру
          mobileZoomImg.style.transform = 'scale(1) translate(0, 0)';
          mobileZoomImg.style.transformOrigin = 'center center';
          isZoomed = false;
        } else {
          // Если не увеличен - закрываем модалку
          closeMobileZoom();
        }
      };
      
      mobileZoomImg._swipeTouchEnd = (e) => {
        // СРАЗУ проверяем состояние зума с новым способом
        let isCurrentlyZoomed = isImageZoomed(mobileZoomImg);
        
        // Отладочная информация
        console.log('TouchEnd - isZoomed:', isCurrentlyZoomed);
        
        // Визуальный индикатор на экране
        showDebugInfo('TouchEnd', isCurrentlyZoomed ? 2 : 1, isCurrentlyZoomed);
        
        // Если в зуме - блокируем только листание, разрешаем панорамирование
        if (isCurrentlyZoomed) {
          isSwiping = false;
          isZoomed = true;
          console.log('TouchEnd в зум режиме - разрешаем панорамирование');
          // НЕ блокируем touchend - разрешаем браузеру обрабатывать панорамирование
          // НЕ делаем return - пусть событие продолжает обрабатываться
        }
        
        // Только если НЕ в зуме и это свайп - листаем изображения
        if (e.changedTouches.length === 1 && isSwiping) {
          const touchEndX = e.changedTouches[0].clientX;
          const touchEndY = e.changedTouches[0].clientY;
          const touchEndTime = Date.now();
          
          const deltaX = touchStartX - touchEndX;
          const deltaY = Math.abs(touchEndY - touchStartY);
          const deltaTime = touchEndTime - touchStartTime;
          
          // Проверяем условия для свайпа
          if (Math.abs(deltaX) > 50 && deltaTime < 500 && deltaY < 100) {
            const oldIndex = curIndex;
            
            if (deltaX > 0) {
              // Свайп влево - следующее изображение
              curIndex = (curIndex + 1) % current.images.length;
            } else {
              // Свайп вправо - предыдущее изображение
              curIndex = (curIndex - 1 + current.images.length) % current.images.length;
            }
            
            // Синхронизируем изображения в обеих модалках
            const mobileMainImg = document.getElementById('mobileMainImg');
            if (mobileMainImg) {
              mobileMainImg.src = `img/${current.images[curIndex]}`;
            }
            mobileZoomImg.src = `img/${current.images[curIndex]}`;
            
            // Сбрасываем трансформацию при смене изображения
            mobileZoomImg.style.transform = 'scale(1) translate(0, 0)';
            mobileZoomImg.style.transformOrigin = 'center center';
            isZoomed = false;
            
            // Обновляем счетчик изображений
            updateMobileImageCounter();
            updateZoomDots();
          }
        }
      };
      
      // Добавляем все обработчики с возможностью блокировки
      mobileZoomImg.addEventListener('touchstart', mobileZoomImg._swipeTouchStart, { passive: false, capture: true });
      mobileZoomImg.addEventListener('touchmove', mobileZoomImg._swipeTouchMove, { passive: false, capture: true });
      mobileZoomImg.addEventListener('touchend', mobileZoomImg._swipeTouchEnd, { passive: false, capture: true });
      mobileZoomImg.addEventListener('gesturestart', (e) => {
        // Разрешаем зум, но блокируем листание
        const transform = window.getComputedStyle(mobileZoomImg).transform;
        const matrix = new DOMMatrix(transform);
        const currentScale = matrix.a;
        if (currentScale > 1.01) {
          isSwiping = false;
          isZoomed = true; // Обновляем глобальный флаг
          // Блокируем жесты листания
          e.preventDefault();
          e.stopPropagation();
        }
      }, { passive: false });
      mobileZoomImg.addEventListener('gesturechange', (e) => {
        // Обновляем состояние зума при изменении масштаба
        const transform = window.getComputedStyle(mobileZoomImg).transform;
        const matrix = new DOMMatrix(transform);
        const currentScale = matrix.a;
        isZoomed = currentScale > 1.01;
        
        // Если в зуме - только сбрасываем флаг свайпа, НЕ блокируем движения
        if (isZoomed) {
          isSwiping = false;
          // НЕ блокируем жесты - разрешаем панорамирование
          // НЕ удаляем обработчики - они нужны для панорамирования
        } else {
          // Если не в зуме - обработчики уже добавлены
        }
      }, { passive: false });
      mobileZoomImg.addEventListener('gestureend', mobileZoomImg._gestureEnd, { passive: true });
      mobileZoomImg.addEventListener('click', mobileZoomImg._clickHandler);
      
      // Дополнительная защита от листания в зум режиме
      mobileZoomImg.addEventListener('wheel', (e) => {
        const transform = window.getComputedStyle(mobileZoomImg).transform;
        const matrix = new DOMMatrix(transform);
        const currentScale = matrix.a;
        if (currentScale > 1.01) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          return false;
        }
      }, { passive: false });
      
      // Блокируем все возможные жесты листания
      mobileZoomImg.addEventListener('scroll', (e) => {
        const transform = window.getComputedStyle(mobileZoomImg).transform;
        const matrix = new DOMMatrix(transform);
        const currentScale = matrix.a;
        if (currentScale > 1.01) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          return false;
        }
      }, { passive: false });
      
      // Убираем глобальную блокировку - она мешает панорамированию
      // Блокировка листания теперь происходит только в обработчиках изображения
    }
  }
  

}

// Обработчик изменения размера окна
window.addEventListener('resize', () => {
  // НЕ закрываем модалки при изменении размера - это может быть интерфейс Safari
  // closeModal();
  // closeMobileModal();
  // closeMobileZoom();
  
  // Обновляем видимость кнопки руководства
  const careBtn = document.getElementById('careBtn');
  const carePanel = document.getElementById('carePanel');
  
  if (careBtn && carePanel) {
    if (currentTab === 'nessffo' && window.innerWidth > 768) {
      careBtn.style.display = 'flex';
    } else {
      careBtn.style.display = 'none';
      carePanel.classList.remove('open');
    }
  }
});

// Обработчик изменения размера viewport (для мобильного Safari)
let lastViewportHeight = window.innerHeight;
window.addEventListener('resize', () => {
  const currentViewportHeight = window.innerHeight;
  const heightDifference = Math.abs(currentViewportHeight - lastViewportHeight);
  
  // Если изменение высоты небольшое (появление/скрытие интерфейса Safari)
  if (heightDifference < 100 && heightDifference > 0) {
    // НЕ закрываем модалки при появлении интерфейса Safari
    return;
  }
  
  lastViewportHeight = currentViewportHeight;
}, { passive: true });

// Функция для обработки скролла и фиксации навигации
function initScrollHandler() {
    const topnav = document.querySelector('.topnav');
  
  if (!topnav) {
    console.error('Topnav element not found!');
    return;
  }
  
  function handleScroll() {
    if (window.scrollY > 8) {
        topnav.classList.add('scrolled');
      } else {
        topnav.classList.remove('scrolled');
      }
    }
  
  // Добавляем обработчик скролла
  window.addEventListener('scroll', handleScroll, { passive: true });
  
  // Вызываем сразу для правильного состояния
  handleScroll();
}

// Функция для настройки обработчиков десктопной модалки
function setupDesktopModalHandlers() {
  const modalLeft = document.getElementById('modalLeft');
  const zoomBtn = document.getElementById('zoomBtn');
  
  // Обработчик клика по основному фото для листания
  if (modalLeft) {
    modalLeft.removeEventListener('click', handleDesktopViewerClick);
    modalLeft.addEventListener('click', handleDesktopViewerClick);
  }
  
  // Обработчик кнопки увеличения
  if (zoomBtn) {
    zoomBtn.removeEventListener('click', handleDesktopZoom);
    zoomBtn.addEventListener('click', handleDesktopZoom);
    
    // Добавляем дополнительные обработчики для отладки
    zoomBtn.addEventListener('mousedown', (e) => {
    });
    
    zoomBtn.addEventListener('mouseup', (e) => {
    });
    
  } else {
    console.error('zoomBtn not found!');
  }
}

// Обработчик клика по основному фото в десктопной версии
function handleDesktopViewerClick(e) {
  if (!current || current.images.length <= 1) return;
  
  // Игнорируем клик по кнопке увеличения
  if (e.target.closest('.zoom-btn')) return;
  
  const modalLeft = e.currentTarget;
  
  // Если в режиме увеличения
  if (modalLeft.classList.contains('zoomed')) {
    // Проверяем, был ли клик по краям экрана для перелистывания
    const windowWidth = window.innerWidth;
    const clickX = e.clientX;
    
    // Если клик в левой четверти экрана - предыдущее фото
    if (clickX < windowWidth / 4) {
      curIndex = (curIndex - 1 + current.images.length) % current.images.length;
      setMainImage(current.images[curIndex]);
      updateThumbnails();
      return;
    }
    // Если клик в правой четверти экрана - следующее фото
    else if (clickX > (windowWidth * 3) / 4) {
      curIndex = (curIndex + 1) % current.images.length;
      setMainImage(current.images[curIndex]);
      updateThumbnails();
      return;
    }
    // Если клик в центре - выходим из режима увеличения
    else {
      handleDesktopZoom();
      return;
    }
  }
  
  // Обычный режим (не увеличенный)
  const rect = modalLeft.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const width = rect.width;
  
  // Если клик в левой трети - предыдущее фото
  if (x < width / 3) {
    curIndex = (curIndex - 1 + current.images.length) % current.images.length;
    setMainImage(current.images[curIndex]);
    updateThumbnails();
  }
  // Если клик в правой трети - следующее фото
  else if (x > (width * 2) / 3) {
    curIndex = (curIndex + 1) % current.images.length;
    setMainImage(current.images[curIndex]);
    updateThumbnails();
  }
}

// Обработчик увеличения в десктопной версии
function handleDesktopZoom() {
  if (!current) {
    return;
  }
  
  // Простое увеличение изображения в том же модальном окне
  const mainImg = document.getElementById('viewerImg');
  const modalLeft = document.getElementById('modalLeft');
  const zoomBtn = document.getElementById('zoomBtn');
  
  if (mainImg && modalLeft) {
    // Переключаем режим увеличения
    if (modalLeft.classList.contains('zoomed')) {
      // Возвращаем к нормальному размеру
      modalLeft.classList.remove('zoomed');
      zoomBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
          <line x1="11" y1="8" x2="11" y2="14"></line>
          <line x1="8" y1="11" x2="14" y2="11"></line>
        </svg>
      `;
      
      // Удаляем обработчик ESC
      document.removeEventListener('keydown', handleEscKey);
      
    } else {
      // Включаем увеличение
      modalLeft.classList.add('zoomed');
      zoomBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      `;
      
      // Добавляем обработчик ESC
      document.addEventListener('keydown', handleEscKey);
      
    }
  } else {
    console.error('Failed to find image elements');
  }
}

// Обработчик клавиши ESC
function handleEscKey(e) {
  if (e.key === 'Escape') {
    const modalLeft = document.getElementById('modalLeft');
    const zoomBtn = document.getElementById('zoomBtn');
    
    if (modalLeft && modalLeft.classList.contains('zoomed')) {
      modalLeft.classList.remove('zoomed');
      zoomBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
          <line x1="11" y1="8" x2="11" y2="14"></line>
          <line x1="8" y1="11" x2="14" y2="11"></line>
        </svg>
      `;
      
      // Удаляем обработчик ESC
      document.removeEventListener('keydown', handleEscKey);
      
    }
  }
}

function closeAllModals() {
  const mobileModal = document.getElementById('mobileModal');
  const mobileZoomModal = document.getElementById('mobileZoomModal');
  const mobileZoomImg = document.getElementById('mobileZoomImg');
  
  if (mobileModal) {
    mobileModal.classList.remove('open');
  }
  
  if (mobileZoomModal) {
    mobileZoomModal.classList.remove('open');
  }
  
  // Сбрасываем состояние зума при закрытии
  if (mobileZoomImg) {
    mobileZoomImg.style.transform = 'scale(1) translate(0, 0)';
    mobileZoomImg.style.transformOrigin = 'center center';
  }
  
  document.body.style.overflow = '';
  document.body.classList.remove('modal-open'); // Полностью разблокируем каталог
  
  // Восстанавливаем позицию скролла мгновенно БЕЗ АНИМАЦИИ
  if (scrollPosition > 0) {
    // Отключаем плавный скролл на время восстановления
    const originalScrollBehavior = document.documentElement.style.scrollBehavior;
    document.documentElement.style.scrollBehavior = 'auto';
    document.body.style.scrollBehavior = 'auto';
    
    // Мгновенное восстановление позиции
    window.scrollTo(0, scrollPosition);
    
    // Возвращаем плавный скролл
    document.documentElement.style.scrollBehavior = originalScrollBehavior;
    document.body.style.scrollBehavior = originalScrollBehavior;
    
    scrollPosition = 0; // Сбрасываем сохраненную позицию
  }
  
  removeMobileEventHandlers();
}


