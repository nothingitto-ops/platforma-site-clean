

// Глобальные переменные
let currentTab = 'home';
let current = null;
let curIndex = 0;
let zoomed = false;
let tx = 0, ty = 0;
let currentHints = [];
let scrollPosition = 0; // Добавляем переменную для сохранения позиции скролла
let isDraggingModal = false; // Флаг для отслеживания перетаскивания модалки
let dragStartX = 0; // Начальная позиция перетаскивания

// DOM элементы
const $modal = document.getElementById('modal');
const $mTitle = document.getElementById('mTitle');
const $mPrice = document.getElementById('mPrice');
const $mDesc = document.getElementById('mDesc');
const $mMeta = document.getElementById('mMeta');
const $mLink = document.getElementById('desktopLink');
const $mStatus = document.getElementById('mStatus');

// Данные товаров
let products = [];

// Загрузка данных из products.json
async function loadProducts() {
  try {
    if (window.loadProductsWithCacheBust) {
      products = await window.loadProductsWithCacheBust();
    } else {
      const response = await fetch('products.json?v=' + new Date().getTime());
      products = await response.json();
    }
    
    // Преобразуем данные в нужный формат
    products = products.map(item => ({
      id: `product_${item.id}`,
      images: item.images.split('|').map(img => img.trim()),
      title: item.title,
      price: item.price,
      desc: item.desc,
      meta: item.meta,
      link: item.link,
      status: item.status,
      order: parseInt(item.order),
      section: item.section
    }));
    
    // Предзагружаем изображения для плавного переключения
    preloadImages();
    
    // Обновляем каталог после загрузки данных
    renderCatalog();
  } catch (error) {
    console.error('Error loading products:', error);
  }
}

// Предзагрузка изображений
function preloadImages() {
  const imagesToPreload = [];
  
  // Добавляем баннеры
  imagesToPreload.push('img/bannerh.jpg', 'img/banner.jpg');
  
  // Добавляем все изображения продуктов
  products.forEach(product => {
    product.images.forEach(image => {
      imagesToPreload.push(`img/${image}`);
    });
  });
  
  // Предзагружаем изображения
  imagesToPreload.forEach(src => {
    const img = new Image();
    img.src = src;
  });
  
}


// Инициализация
document.addEventListener('DOMContentLoaded', () => {
  try {
    // Очищаем класс modal-open при загрузке страницы
    document.body.classList.remove('modal-open');
    document.body.style.overflow = '';
    
    initTabs();
    initFilters();
    initCarePanel();
    initScrollHandler();
    loadProducts(); // Загружаем данные из products.json
    loadHero();
    
    // Принудительно исправляем стили кнопки
    setTimeout(() => {
      const ctaButtons = document.querySelectorAll('.cta, #desktopLink.cta, .mobile-modal .cta');
      ctaButtons.forEach(btn => {
        btn.style.borderRadius = '0';
        btn.style.webkitBorderRadius = '0';
        btn.style.mozBorderRadius = '0';
        btn.style.width = '100vw';
        btn.style.maxWidth = '100vw';
        btn.style.left = '0';
        btn.style.right = '0';
        btn.style.marginLeft = '0';
        btn.style.marginRight = '0';
      });
    }, 100);
    
  } catch (error) {
    console.error('Error during initialization:', error);
  }
});

// Функции для вкладок
function initTabs() {
  const tabs = document.querySelectorAll('.tab');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      const section = tab.dataset.tab;
      switchTab(section);
    });
  });
}

function switchTab(section) {
  currentTab = section;
  
  // Очищаем состояние модалок при переключении вкладок
  closeAllModals();
  
  // Обновляем активную вкладку
  document.querySelectorAll('.tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.tab === section);
  });
  
  // Прокручиваем страницу вверх только если не было открытой модалки
  if (scrollPosition === 0) {
    window.scrollTo({ 
      top: 0, 
      behavior: 'instant' // Мгновенная прокрутка без анимации
    });
  }
  
  // Обновляем баннер
  loadHero();
  
  // Быстрая фильтрация каталога
  filterCatalog('all');
  
  // Устанавливаем атрибут data-section для стилей
  document.body.setAttribute('data-section', section);
  
  // Показываем/скрываем панель ухода и кнопку руководства
  const carePanel = document.getElementById('carePanel');
  const careBtn = document.getElementById('careBtn');
  
  if (carePanel) {
    if (section === 'nessffo') {
      // На десктопе панель изначально скрыта, на мобильных - показана
      if (window.innerWidth > 768) {
        carePanel.style.display = 'none';
        carePanel.classList.remove('open');
      } else {
        carePanel.style.display = 'block';
        carePanel.classList.remove('collapsed');
      }
    } else {
      carePanel.style.display = 'none';
      carePanel.classList.remove('open');
    }
  }
  
  // Показываем/скрываем кнопку руководства
  if (careBtn) {
    if (section === 'nessffo' && window.innerWidth > 768) {
      careBtn.style.display = 'flex';
    } else {
      careBtn.style.display = 'none';
    }
  }
}

// Функции для фильтров
function initFilters() {
  const filters = document.querySelectorAll('.fbtn');
  filters.forEach(filter => {
    filter.addEventListener('click', () => {
      const filterType = filter.dataset.filter;
      applyFilter(filterType);
    });
  });
}

function applyFilter(filterType) {
  // Обновляем активный фильтр
  document.querySelectorAll('.fbtn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.filter === filterType);
  });
  
  // Быстрая фильтрация без пересоздания DOM
  filterCatalog(filterType);
}

// Новая функция для быстрой фильтрации
function filterCatalog(filterType = 'all') {
  const cards = document.querySelectorAll('.card');
  
  cards.forEach(card => {
    const itemId = card.dataset.id;
    const item = products.find(p => p.id === itemId);
    
    if (item) {
      let shouldShow = true;
      
      // Проверяем соответствие текущей вкладке
      if (item.section !== currentTab) {
        shouldShow = false;
      } else {
        // Проверяем фильтр по статусу
        if (filterType === 'stock' && item.status !== 'stock') {
          shouldShow = false;
        } else if (filterType === 'preorder' && item.status !== 'preorder') {
          shouldShow = false;
        }
      }
      
      // Показываем/скрываем карточку
      if (shouldShow) {
        card.style.display = 'block';
        card.style.opacity = '1';
        card.style.visibility = 'visible';
      } else {
        card.style.display = 'none';
        card.style.opacity = '0';
        card.style.visibility = 'hidden';
      }
    }
  });
}

// Функции для панели ухода
function initCarePanel() {
  const carePanel = document.getElementById('carePanel');
  const careBtn = document.getElementById('careBtn');
  
  if (carePanel) {
    // Обработчик для панели (сворачивание при клике на заголовок только на мобильных)
    const careTitle = carePanel.querySelector('h4');
    if (careTitle) {
      careTitle.addEventListener('click', () => {
        if (window.innerWidth <= 768) {
          // Только на мобильных
          carePanel.classList.toggle('collapsed');
        }
      });
    }
  }
  
  // Обработчик для кнопки руководства
  if (careBtn) {
    careBtn.addEventListener('click', () => {
      if (carePanel) {
        carePanel.classList.toggle('open');
      }
    });
  }
}

// Функции для баннера
function loadHero() {
  const hero = document.querySelector('.hero');
  if (hero) {
    const banner = currentTab === 'home' ? 'bannerh.jpg' : 'banner.jpg';
    hero.src = `img/${banner}`;
    hero.alt = currentTab === 'home' ? 'Главная страница' : 'Nessffo Collection';
    hero.style.opacity = '1';
    hero.style.visibility = 'visible';
  } else {
    console.error('Hero element not found');
  }
}

// Функции для каталога
function renderCatalog(filterType = 'all') {
  const catalog = document.getElementById('catalog');
  if (!catalog) return;
  
  // Создаем все карточки сразу для быстрой фильтрации
  const allCards = products.map(item => createCard(item)).join('');
  catalog.innerHTML = allCards;
  
  // Добавляем обработчики событий
  addCardEventListeners();
  
  // Применяем фильтр
  filterCatalog(filterType);
  
  // Показываем каталог
  catalog.style.opacity = '1';
  catalog.style.visibility = 'visible';
  catalog.style.display = 'grid';
}

function createCard(item) {
  const statusText = item.status === 'preorder' ? 'под заказ' : 'в наличии';
  const statusClass = item.status === 'preorder' ? 'pre' : 'in';
  
  // Форматируем цену с пробелами и символом рубля
  const priceText = item.price.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ') + ' ₽';
  
  return `
    <div class="card" data-id="${item.id}">
      <div class="card-img">
        <img src="img/${item.images[0]}" alt="${item.title}" loading="lazy">
      </div>
      <h3>${item.title}</h3>
      <div class="price">${priceText}</div>
      <div class="status ${statusClass}">${statusText}</div>
    </div>
  `;
}

function addCardEventListeners() {
  const cards = document.querySelectorAll('.card');
  cards.forEach(card => {
    const itemId = card.dataset.id;
    const item = products.find(p => p.id === itemId);
    
    if (item) {
      // Обработчик клика
      card.addEventListener('click', () => openModal(item, currentTab));
      
      // Эффект смены изображений при наведении (только для десктопа)
      if (window.innerWidth > 768) {
        const imgBox = card.querySelector('.card-img');
        const img = imgBox.querySelector('img');
        
        if (imgBox && img && item.images.length > 1) {
          let isHovering = false;
          let hoverRaf = 0;
          let currentHoverIndex = 0;
          
          const applyIdx = (idx) => {
            if (idx !== currentHoverIndex && idx < item.images.length) {
              currentHoverIndex = idx;
              img.src = `img/${item.images[idx]}`;
            }
          };
          
          imgBox.addEventListener('mouseenter', () => {
            isHovering = true;
          });
          
          imgBox.addEventListener('mousemove', e => {
            if (!isHovering) return;
            
            if (hoverRaf) {
              cancelAnimationFrame(hoverRaf);
            }
            
            hoverRaf = requestAnimationFrame(() => {
              hoverRaf = 0;
              const rect = imgBox.getBoundingClientRect();
              const ratio = (e.clientX - rect.left) / rect.width;
              const idx = Math.min(item.images.length - 1, Math.max(0, Math.floor(ratio * item.images.length)));
              if (idx !== currentHoverIndex) {
                applyIdx(idx);
              }
            });
          });
          
          imgBox.addEventListener('mouseout', () => {
            isHovering = false;
            if (hoverRaf) {
              cancelAnimationFrame(hoverRaf);
              hoverRaf = 0;
            }
            if (currentHoverIndex !== 0) {
              applyIdx(0);
            }
          });
          
          imgBox.addEventListener('mouseleave', () => {
            isHovering = false;
            if (hoverRaf) {
              cancelAnimationFrame(hoverRaf);
              hoverRaf = 0;
            }
            if (currentHoverIndex !== 0) {
              applyIdx(0);
            }
          });
        }
      }
    }
  });
}

// Функции для модального окна (десктоп)
function openModal(item, section) {
  // Проверяем размер экрана для определения мобильной/десктопной версии
  const isMobile = window.innerWidth <= 768;
  
  if (isMobile) {
    // Для мобильной версии открываем новую модалку
    openMobileModal(item, section);
  } else {
    // Для десктопной версии открываем обычную модалку
    openDesktopModal(item, section);
  }
}

function openDesktopModal(item, section) {
  current = item;
  curIndex = 0;
  
  // Заполняем информацию
  $mTitle.textContent = item.title;
  
  // Форматируем цену
  const priceText = item.price.replace(' ₽', '').replace(' р.', '').replace('р', '');
  const formattedPrice = priceText.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ') + ' ₽';
  
  // Создаем контейнер для цены и статуса
  $mPrice.innerHTML = '';
  const priceContainer = document.createElement('div');
  priceContainer.className = 'modal-price-container';
  priceContainer.style.display = 'flex';
  priceContainer.style.justifyContent = 'center';
  priceContainer.style.alignItems = 'center';
  priceContainer.style.gap = '12px';
  priceContainer.style.flexWrap = 'wrap';
  
  const priceElement = document.createElement('span');
  priceElement.className = 'price-text';
  priceElement.textContent = formattedPrice;
  priceContainer.appendChild(priceElement);
  
  // Добавляем статус
  if (item.status) {
    const statusElement = document.createElement('span');
    const cls = (item.status === 'preorder') ? 'pre' : 'in';
    statusElement.className = 'modal-status ' + cls;
    statusElement.textContent = (item.status === 'preorder') ? 'под заказ' : 'в наличии';
    priceContainer.appendChild(statusElement);
  }
  
  $mPrice.appendChild(priceContainer);
  
  $mDesc.textContent = item.desc;
  $mMeta.textContent = item.meta || '';
  $mLink.href = item.link;
  
  // Устанавливаем изображение
  setMainImage(item.images[0]);
  renderThumbnails(item.images);
  
  // Добавляем обработчики для десктопной версии
  setupDesktopModalHandlers();
  
  // Открываем модалку
  $modal.classList.add('open');
  document.body.style.overflow = 'hidden';
}

function setMainImage(src) {
  const viewerImg = document.getElementById('viewerImg');
  if (viewerImg) {
    viewerImg.src = `img/${src}`;
  }
  
  // Добавляем обработчики кликов для листания фото
  const viewer = document.querySelector('.viewer');
  if (viewer && current) {
    // Удаляем старые обработчики
    viewer.removeEventListener('click', handleViewerClick);
    // Добавляем новый обработчик
    viewer.addEventListener('click', handleViewerClick);
  }
}

function handleViewerClick(e) {
  if (!current || current.images.length <= 1) return;
  
  const rect = e.currentTarget.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const width = rect.width;
  
  // Если клик в левой трети - предыдущее фото
  if (x < width / 3) {
    curIndex = (curIndex - 1 + current.images.length) % current.images.length;
    setMainImage(current.images[curIndex]);
    updateThumbnails();
  }
  // Если клик в правой трети - следующее фото
  else if (x > (width * 2) / 3) {
    curIndex = (curIndex + 1) % current.images.length;
    setMainImage(current.images[curIndex]);
    updateThumbnails();
  }
}

function handleMobileViewerClick(e) {
  if (!current || current.images.length <= 1) return;
  
  const rect = e.currentTarget.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const width = rect.width;
  
  // Если клик в левой трети - предыдущее фото
  if (x < width / 3) {
    curIndex = (curIndex - 1 + current.images.length) % current.images.length;
    const mobileMainImg = document.getElementById('mobileMainImg');
    if (mobileMainImg) {
      mobileMainImg.src = `img/${current.images[curIndex]}`;
    }
  }
  // Если клик в правой трети - следующее фото
  else if (x > (width * 2) / 3) {
    curIndex = (curIndex + 1) % current.images.length;
    const mobileMainImg = document.getElementById('mobileMainImg');
    if (mobileMainImg) {
      mobileMainImg.src = `img/${current.images[curIndex]}`;
    }
  }
}

function handleMobileZoomClick(e) {
  if (!current || current.images.length <= 1) return;
  
  const rect = e.currentTarget.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const width = rect.width;
  
  // Если клик в левой трети - предыдущее фото
  if (x < width / 3) {
    curIndex = (curIndex - 1 + current.images.length) % current.images.length;
    const mobileMainImg = document.getElementById('mobileMainImg');
    const mobileZoomImg = document.getElementById('mobileZoomImg');
    if (mobileMainImg) {
      mobileMainImg.src = `img/${current.images[curIndex]}`;
    }
    if (mobileZoomImg) {
      mobileZoomImg.src = `img/${current.images[curIndex]}`;
    }
  }
  // Если клик в правой трети - следующее фото
  else if (x > (width * 2) / 3) {
    curIndex = (curIndex + 1) % current.images.length;
    const mobileMainImg = document.getElementById('mobileMainImg');
    const mobileZoomImg = document.getElementById('mobileZoomImg');
    if (mobileMainImg) {
      mobileMainImg.src = `img/${current.images[curIndex]}`;
    }
    if (mobileZoomImg) {
      mobileZoomImg.src = `img/${current.images[curIndex]}`;
    }
  }
}

function renderThumbnails(images) {
  const thumbs = document.getElementById('thumbs');
  if (!thumbs) return;
  
  thumbs.innerHTML = '';
  images.forEach((imagePath, idx) => {
    const thumb = document.createElement('img');
    thumb.src = `img/${imagePath}`;
    thumb.alt = '';
    thumb.className = `thumb ${idx === 0 ? 'active' : ''}`;
    thumb.addEventListener('click', () => {
      curIndex = idx;
      setMainImage(imagePath);
      updateThumbnails();
    });
    thumbs.appendChild(thumb);
  });
}

function updateThumbnails() {
  const thumbs = document.querySelectorAll('#thumbs .thumb');
  thumbs.forEach((thumb, idx) => {
    thumb.classList.toggle('active', idx === curIndex);
  });
}

function closeModal() {
  $modal.classList.remove('open');
  document.body.style.overflow = '';
}

// Обработчики событий для десктопной модалки
if ($modal) {
  $modal.addEventListener('click', closeModal);
}

const closeBtn = document.getElementById('closeBtn');
if (closeBtn) {
  closeBtn.addEventListener('click', closeModal);
}

// ===== ФУНКЦИИ ДЛЯ МОБИЛЬНОЙ МОДАЛКИ =====
function openMobileModal(item, section) {
  current = item;
  curIndex = 0;
  
  // Находим элементы мобильной модалки
  const mobileModal = document.getElementById('mobileModal');
  const mobileTitle = document.getElementById('mobileTitle');
  const mobilePrice = document.getElementById('mobilePrice');
  const mobileDesc = document.getElementById('mobileDesc');

  const mobileMainImg = document.getElementById('mobileMainImg');
  const mobileDots = document.getElementById('mobileDots');
  const mobileLink = document.getElementById('mobileLink');
  
  if (!mobileModal || !mobileTitle || !mobilePrice || !mobileDesc || !mobileMainImg || !mobileLink) {
    console.error('Не найдены элементы мобильной модалки');
    return;
  }
  
  // Заполняем информацию о товаре
  mobileTitle.textContent = item.title;
  
  // Форматируем цену и добавляем статус
  const priceText = item.price.replace(' ₽', '').replace(' р.', '').replace('р', '');
  const formattedPrice = priceText.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ') + ' ₽';
  
  // Очищаем контейнер цены
  mobilePrice.innerHTML = '';
  
  // Добавляем цену
  const priceElement = document.createElement('span');
  priceElement.textContent = formattedPrice;
  priceElement.className = 'mobile-price-text';
  mobilePrice.appendChild(priceElement);
  
  // Добавляем статус рядом с ценой
    if (item.status) {
    const statusElement = document.createElement('span');
    const statusLabel = (item.status === 'preorder') ? 'под заказ' : 'в наличии';
    statusElement.textContent = ' ' + statusLabel;
    statusElement.style.marginLeft = '8px';
    statusElement.style.padding = '2px 6px';
    statusElement.style.borderRadius = '4px';
    statusElement.style.fontSize = '12px';
    statusElement.style.fontWeight = '500';
    statusElement.style.color = item.status === 'preorder' ? '#92400e' : '#065f46';
    statusElement.style.backgroundColor = item.status === 'preorder' ? '#fef3c7' : '#f0fdf4';
    statusElement.style.opacity = '0.8';
    statusElement.style.verticalAlign = 'middle';
    statusElement.style.display = 'inline-block';
    mobilePrice.appendChild(statusElement);
  }
  
  mobileDesc.textContent = item.desc;
  
  // Настройка кнопки "Состав" - только клик
  const mobileCompositionBtn = document.getElementById('mobileCompositionBtn');
  if (mobileCompositionBtn) {
    // Сбрасываем состояние кнопки
    mobileCompositionBtn.classList.remove('active');
    mobileCompositionBtn.textContent = '?';
    
    // Удаляем ВСЕ возможные обработчики
    mobileCompositionBtn.removeEventListener('click', mobileCompositionBtn._clickHandler);
    
    // Создаем новый обработчик только для клика
    mobileCompositionBtn._clickHandler = function(e) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      
      // Мгновенное переключение
      if (this.classList.contains('active')) {
        // Показываем описание
        this.classList.remove('active');
        this.textContent = '?';
        mobileDesc.textContent = item.desc;
      } else {
        // Показываем состав
        this.classList.add('active');
        this.textContent = '?';
        mobileDesc.textContent = item.meta;
      }
    };
    
    // Добавляем только обработчик клика с высоким приоритетом
    mobileCompositionBtn.addEventListener('click', mobileCompositionBtn._clickHandler, { capture: true });
  }
  

  mobileLink.href = item.link;
  
  // Устанавливаем первое изображение
  mobileMainImg.src = `img/${item.images[0]}`;
  mobileMainImg.alt = item.title;
  
  // Показываем счетчик изображений в левом верхнем углу
  if (mobileDots && item.images.length > 1) {
    mobileDots.style.display = 'flex';
    mobileDots.style.justifyContent = 'center';
    mobileDots.style.alignItems = 'center';
    mobileDots.style.position = 'absolute';
    mobileDots.style.top = '16px';
    mobileDots.style.left = '16px';
    mobileDots.style.background = 'rgba(0, 0, 0, 0.5)';
    mobileDots.style.color = 'white';
    mobileDots.style.padding = '4px 8px';
    mobileDots.style.borderRadius = '8px';
    mobileDots.style.fontSize = '12px';
    mobileDots.style.fontWeight = '500';
    mobileDots.style.zIndex = '5';
    mobileDots.style.pointerEvents = 'none'; // Не блокирует свайпы
    mobileDots.style.width = 'auto';
    mobileDots.style.height = 'auto';
    mobileDots.style.textAlign = 'center';
    mobileDots.innerHTML = `1 / ${item.images.length}`;
  } else if (mobileDots) {
    mobileDots.style.display = 'none';
    mobileDots.innerHTML = '';
  }
  
  // ОЧИЩАЕМ ВСЕ СТАРЫЕ ОБРАБОТЧИКИ ПЕРЕД ДОБАВЛЕНИЕМ НОВЫХ
  const mobileMainImage = document.querySelector('.mobile-main-image');
  const mobileModalElement = document.getElementById('mobileModal');
  
  if (mobileMainImage) {
    // Удаляем все старые обработчики
    mobileMainImage.removeEventListener('click', handleMobileViewerClick);
    mobileMainImage.removeEventListener('click', openMobileZoom);
    mobileMainImage.removeEventListener('touchstart', mobileMainImage._touchStartHandler);
    mobileMainImage.removeEventListener('touchmove', mobileMainImage._touchMoveHandler);
    mobileMainImage.removeEventListener('touchend', mobileMainImage._touchEndHandler);
    
    // Добавляем обработчик клика для зума
    mobileMainImage.addEventListener('click', (e) => {
      // Проверяем, что клик не по кнопке закрытия
      if (e.target.closest('#mobileCloseBtn') || e.target.closest('.mobile-close-btn')) {
        return; // Не открываем зум если клик по крестику
      }
      openMobileZoom(e);
    }, true); // Добавляем capture phase
    
    // Дублируем обработчик для надежности
    mobileMainImage.onclick = (e) => {
      // Проверяем, что клик не по кнопке закрытия
      if (e.target.closest('#mobileCloseBtn') || e.target.closest('.mobile-close-btn')) {
        return; // Не открываем зум если клик по крестику
      }
      openMobileZoom(e);
    };
  }
  
  if (mobileModalElement) {
    // Удаляем старые обработчики свайпа закрытия
    mobileModalElement.removeEventListener('touchstart', mobileModalElement._swipeCloseTouchStart);
    mobileModalElement.removeEventListener('touchmove', mobileModalElement._swipeCloseTouchMove);
    mobileModalElement.removeEventListener('touchend', mobileModalElement._swipeCloseTouchEnd);
    
    // Добавляем обработчик свайпа закрытия на весь контейнер модалки
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    let isDraggingModal = false;
    let dragStartX = 0;
    
    mobileModalElement._swipeCloseTouchStart = (e) => {
        if (e.touches.length === 1) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          touchStartTime = Date.now();
          
          // Если свайп начинается с левого края экрана, включаем режим перетаскивания
          if (touchStartX < 50) {
            isDraggingModal = true;
            dragStartX = touchStartX;
          }
        }
      };
      
      mobileModalElement._swipeCloseTouchMove = (e) => {
        if (e.touches.length === 1 && isDraggingModal && touchStartX < 50) {
          const touchX = e.touches[0].clientX;
          const dragDeltaX = touchX - dragStartX;
          
          if (dragDeltaX > 0) {
            // Применяем визуальный эффект сдвига
            const translateX = Math.min(dragDeltaX, window.innerWidth);
            mobileModalElement.style.transform = `translateX(${translateX}px)`;
            mobileModalElement.style.transition = 'none';
            
            // Добавляем затемнение при перетаскивании
            const overlay = mobileModalElement.querySelector('.mobile-modal-content');
            if (overlay) {
              const opacity = Math.max(0.3, 1 - (dragDeltaX / window.innerWidth) * 0.7);
              overlay.style.opacity = opacity;
            }
          }
        }
      };
      
      mobileModalElement._swipeCloseTouchEnd = (e) => {
        if (e.changedTouches.length === 1 && isDraggingModal && touchStartX < 50) {
          const touchEndX = e.changedTouches[0].clientX;
          const dragDeltaX = touchEndX - dragStartX;
          
          if (dragDeltaX > 100) {
            // Закрываем модалку с анимацией
            mobileModalElement.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            mobileModalElement.style.transform = `translateX(${window.innerWidth}px)`;
            const overlay = mobileModalElement.querySelector('.mobile-modal-content');
            if (overlay) {
              overlay.style.transition = 'opacity 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
              overlay.style.opacity = '0';
            }
            setTimeout(() => {
              closeAllModals();
              // Сбрасываем стили
              mobileModalElement.style.transform = '';
              mobileModalElement.style.transition = '';
              if (overlay) {
                overlay.style.opacity = '';
                overlay.style.transition = '';
              }
            }, 400);
          } else {
            // Возвращаем модалку на место с пружинной анимацией
            mobileModalElement.style.transition = 'transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
            mobileModalElement.style.transform = '';
            const overlay = mobileModalElement.querySelector('.mobile-modal-content');
            if (overlay) {
              overlay.style.transition = 'opacity 0.3s ease-out';
              overlay.style.opacity = '1';
            }
            setTimeout(() => {
              mobileModalElement.style.transition = '';
              if (overlay) {
                overlay.style.transition = '';
              }
            }, 300);
          }
          isDraggingModal = false;
        }
      };
      
      // Добавляем обработчики
      mobileModalElement.addEventListener('touchstart', mobileModalElement._swipeCloseTouchStart, { passive: true });
      mobileModalElement.addEventListener('touchmove', mobileModalElement._swipeCloseTouchMove, { passive: true });
      mobileModalElement.addEventListener('touchend', mobileModalElement._swipeCloseTouchEnd, { passive: false });
    }
    
    // НОВАЯ ЛОГИКА: Обработчики для листания изображений в основной модалке
    if (current && current.images.length > 1) {
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartTime = 0;
      let isSwiping = false;
      
      // Сохраняем ссылки на функции для возможности удаления
      mobileMainImage._touchStartHandler = (e) => {
        if (e.touches.length === 1) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          touchStartTime = Date.now();
          isSwiping = false;
          // Для старых Android - не вызываем preventDefault
        }
      };
      
      mobileMainImage._touchMoveHandler = (e) => {
        if (e.touches.length === 1) {
          const currentX = e.touches[0].clientX;
          const currentY = e.touches[0].clientY;
          const deltaX = Math.abs(currentX - touchStartX);
          const deltaY = Math.abs(currentY - touchStartY);
          
          // Улучшенная логика для Android и iPhone
          if (deltaX > 10 && deltaX > deltaY * 1.5) {
            isSwiping = true;
            e.preventDefault(); // Для Android
          }
        }
      };
      
      mobileMainImage._touchEndHandler = (e) => {
        if (e.changedTouches.length === 1 && isSwiping) {
          const touchEndX = e.changedTouches[0].clientX;
          const touchEndY = e.changedTouches[0].clientY;
          const touchEndTime = Date.now();
          
          const deltaX = touchStartX - touchEndX;
          const deltaY = Math.abs(touchEndY - touchStartY);
          const deltaTime = touchEndTime - touchStartTime;
          
          // Улучшенные условия для Android и iPhone
          if (Math.abs(deltaX) > 30 && deltaTime < 500 && deltaY < 100) {
            const oldIndex = curIndex;
            
            if (deltaX > 0) {
              // Свайп влево - следующее изображение
              curIndex = (curIndex + 1) % current.images.length;
            } else {
              // Свайп вправо - предыдущее изображение
              curIndex = (curIndex - 1 + current.images.length) % current.images.length;
            }
            
            // Обновляем изображение
            const mobileMainImg = document.getElementById('mobileMainImg');
            if (mobileMainImg) {
              mobileMainImg.src = `img/${current.images[curIndex]}`;
            }
            
            // Обновляем счетчик изображений
            updateMobileImageCounter();
            updateZoomDots();
            

          }
        }
      };
      
      // Добавляем обработчики для Android и iPhone
      mobileMainImage.addEventListener('touchstart', mobileMainImage._touchStartHandler, { passive: true });
      mobileMainImage.addEventListener('touchmove', mobileMainImage._touchMoveHandler, { passive: false });
      mobileMainImage.addEventListener('touchend', mobileMainImage._touchEndHandler, { passive: false });
  }
  
  // Сбрасываем все состояния перед открытием модалки
  isSwiping = false;
  isZoomed = false;
  isDraggingModal = false;
  touchStartX = 0;
  touchStartY = 0;
  touchStartTime = 0;
  
  // Открываем модалку
  mobileModalElement.classList.add('open');
  scrollPosition = window.pageYOffset; // Сохраняем позицию скролла
  document.body.style.overflow = 'hidden';
  document.body.classList.add('modal-open'); // Добавляем класс для блокировки каталога
  
  // Добавляем обработчики событий ПОСЛЕ открытия модалки
  setTimeout(() => {
    addMobileEventHandlers();
  }, 100);
}

function updateMobileImageCounter() {
  const mobileDots = document.getElementById('mobileDots');
  if (mobileDots && current && current.images.length > 1) {
    mobileDots.innerHTML = `${curIndex + 1} / ${current.images.length}`;
  }
}

function closeMobileModal() {
  closeAllModals();
}

function closeMobileModalWithAnimation() {
  // Плавное закрытие с анимацией
  const mobileModal = document.getElementById('mobileModal');
  if (mobileModal) {
    // Добавляем плавную анимацию закрытия
    mobileModal.style.transition = 'opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.25s cubic-bezier(0.4, 0, 0.2, 1)';
    mobileModal.classList.remove('open');
    
    // Ждем завершения анимации перед полным закрытием
    setTimeout(() => {
      closeAllModals();
    }, 250);
  } else {
    closeAllModals();
  }
}

function addMobileEventHandlers() {
  const mobileCloseBtn = document.getElementById('mobileCloseBtn');
  const mobileModal = document.getElementById('mobileModal');
  const mobileInfoBlock = document.querySelector('.mobile-info-block');
  
  if (mobileCloseBtn) {
    mobileCloseBtn.removeEventListener('click', closeMobileModal);
    mobileCloseBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeMobileModal();
    }, true); // Добавляем capture phase
    
    // Дублируем обработчик для надежности
    mobileCloseBtn.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeMobileModal();
    };
  }
  
  // Добавляем обработчик жеста "назад" для основной модалки
  if (mobileModal) {
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    
    mobileModal.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
      }
    }, { passive: true });
    
    mobileModal.addEventListener('touchend', (e) => {
      if (e.changedTouches.length === 1) {
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const touchEndTime = Date.now();
        
        const deltaX = touchEndX - touchStartX; // Обратное направление для жеста "назад"
        const deltaY = Math.abs(touchEndY - touchStartY);
        const deltaTime = touchEndTime - touchStartTime;
        
        // Жест "назад" в Safari: свайп справа налево с левого края экрана
        if (deltaX > 100 && deltaTime > 300 && deltaY < 50 && touchStartX < 50) {
          closeMobileModalWithAnimation();
          return;
        }
      }
    }, { passive: false });
  }
  
  // Добавляем обработчик клавиши Escape
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      closeAllModals();
    }
  });
  
  // Добавляем делегирование событий для кнопки закрытия
  document._mobileCloseHandler = (e) => {
    if (e.target.closest('#mobileCloseBtn') || e.target.closest('.mobile-close-btn')) {
      e.preventDefault();
      e.stopPropagation();
      closeMobileModal();
    }
  };
  document.addEventListener('click', document._mobileCloseHandler, true);
  
  // Добавляем делегирование событий для зума
  document._mobileZoomHandler = (e) => {
    if (e.target.closest('.mobile-main-image') && !e.target.closest('#mobileCloseBtn') && !e.target.closest('.mobile-close-btn')) {
      e.preventDefault();
      e.stopPropagation();
      openMobileZoom(e);
    }
  };
  document.addEventListener('click', document._mobileZoomHandler, true);
  
  // Специальная обработка для старых Android - добавляем touchstart
  document._mobileTouchHandler = (e) => {
    if (e.target.closest('.mobile-main-image') && !e.target.closest('#mobileCloseBtn') && !e.target.closest('.mobile-close-btn')) {
      // Для старых Android - открываем зум по touchstart
      const userAgent = navigator.userAgent.toLowerCase();
      if (userAgent.includes('android') && (userAgent.includes('4.0') || userAgent.includes('4.1') || userAgent.includes('4.2') || userAgent.includes('4.3') || userAgent.includes('4.4'))) {
        e.preventDefault();
        e.stopPropagation();
        openMobileZoom(e);
      }
    }
  };
  document.addEventListener('touchstart', document._mobileTouchHandler, true);
  
  // Убираем блокирующие обработчики для текстового блока и кнопки CTA
  // Они мешают жесту "назад" и листанию изображений
  // Теперь все свайпы обрабатываются централизованно
}

function removeMobileEventHandlers() {
  const mobileCloseBtn = document.getElementById('mobileCloseBtn');
  const mobileZoomBtn = document.getElementById('mobileZoomBtn');
  const mobileModal = document.getElementById('mobileModal');
  
  if (mobileCloseBtn) {
    mobileCloseBtn.removeEventListener('click', closeMobileModal);
    mobileCloseBtn.onclick = null; // Убираем onclick
  }
  
  if (mobileZoomBtn) {
    mobileZoomBtn.removeEventListener('click', openMobileZoom);
  }
  
  if (mobileModal) {
    // Убираем обработчики touch событий
    mobileModal.removeEventListener('touchstart', mobileModal._touchStartHandler);
    mobileModal.removeEventListener('touchend', mobileModal._touchEndHandler);
  }
  
  // Убираем делегированные обработчики
  document.removeEventListener('click', document._mobileCloseHandler);
  document.removeEventListener('click', document._mobileZoomHandler);
  document.removeEventListener('touchstart', document._mobileTouchHandler);
}

// ===== ФУНКЦИИ ДЛЯ ЗУМА В МОБИЛЬНОЙ МОДАЛКЕ =====
function openMobileZoom() {
  const mobileZoomModal = document.getElementById('mobileZoomModal');
  const mobileZoomImg = document.getElementById('mobileZoomImg');
  const mobileMainImg = document.getElementById('mobileMainImg');
  
  if (!mobileZoomModal || !mobileZoomImg || !mobileMainImg) {
    return;
  }
  
  // Копируем текущее изображение в зум модалку
  mobileZoomImg.src = mobileMainImg.src;
  mobileZoomImg.alt = '';
  
  // Убираем закругления
  mobileZoomImg.style.borderRadius = '0';
  
  // Показываем счетчик в зум режиме в левом верхнем углу
  const zoomDotsContainer = document.getElementById('mobileZoomDots');
  if (zoomDotsContainer && current && current.images.length > 1) {
    zoomDotsContainer.style.display = 'flex';
    zoomDotsContainer.style.justifyContent = 'center';
    zoomDotsContainer.style.alignItems = 'center';
    zoomDotsContainer.style.position = 'absolute';
    zoomDotsContainer.style.top = '16px';
    zoomDotsContainer.style.left = '16px';
    zoomDotsContainer.style.background = 'rgba(0, 0, 0, 0.5)';
    zoomDotsContainer.style.color = 'white';
    zoomDotsContainer.style.padding = '4px 8px';
    zoomDotsContainer.style.borderRadius = '8px';
    zoomDotsContainer.style.fontSize = '12px';
    zoomDotsContainer.style.fontWeight = '500';
    zoomDotsContainer.style.zIndex = '5';
    zoomDotsContainer.style.pointerEvents = 'none'; // Не блокирует свайпы
    zoomDotsContainer.style.width = 'auto';
    zoomDotsContainer.style.height = 'auto';
    zoomDotsContainer.style.textAlign = 'center';
    zoomDotsContainer.innerHTML = `${curIndex + 1} / ${current.images.length}`;
  } else if (zoomDotsContainer) {
    zoomDotsContainer.style.display = 'none';
    zoomDotsContainer.innerHTML = '';
  }
  
  mobileZoomModal.classList.add('open');
  document.body.style.overflow = 'hidden';
  addMobileZoomEventHandlers();
  
  // Убираем клики для листания в зум-версии - только свайпы
  const mobileZoomContent = document.querySelector('.mobile-zoom-content');
  if (mobileZoomContent) {
    // Убираем блокирующие обработчики - они мешают жесту "назад" и листанию
    // Обработчики свайпов теперь в addMobileZoomEventHandlers()
  }
}

function updateZoomDots() {
  const zoomDotsContainer = document.getElementById('mobileZoomDots');
  if (zoomDotsContainer && current && current.images.length > 1) {
    zoomDotsContainer.innerHTML = `${curIndex + 1} / ${current.images.length}`;
  }
}

function closeMobileZoom() {
  const mobileZoomModal = document.getElementById('mobileZoomModal');
  if (mobileZoomModal) {
    mobileZoomModal.classList.remove('open');
    // Возвращаемся в обычную модалку, не закрываем все
    document.body.style.overflow = 'hidden';
    
    // Сбрасываем состояние зума
    const mobileZoomImg = document.getElementById('mobileZoomImg');
    if (mobileZoomImg) {
      mobileZoomImg.style.transform = 'scale(1) translate(0, 0)';
      mobileZoomImg.style.transformOrigin = 'center center';
    }
  }
}

function addMobileZoomEventHandlers() {
  const mobileZoomCloseBtn = document.getElementById('mobileZoomCloseBtn');
  const mobileZoomImg = document.getElementById('mobileZoomImg');
  const mobileZoomModal = document.getElementById('mobileZoomModal');
  
  // ОЧИЩАЕМ ВСЕ СТАРЫЕ ОБРАБОТЧИКИ ПЕРЕД ДОБАВЛЕНИЕМ НОВЫХ
  if (mobileZoomCloseBtn) {
    mobileZoomCloseBtn.removeEventListener('click', closeMobileZoom);
    mobileZoomCloseBtn.addEventListener('click', closeMobileZoom);
  }
  
  if (mobileZoomModal) {
    // Удаляем старые обработчики жеста "назад"
    mobileZoomModal.removeEventListener('touchstart', mobileZoomModal._backGestureTouchStart);
    mobileZoomModal.removeEventListener('touchend', mobileZoomModal._backGestureTouchEnd);
  }
  
  if (mobileZoomImg) {
    // Удаляем старые обработчики свайпов
    mobileZoomImg.removeEventListener('touchstart', mobileZoomImg._swipeTouchStart);
    mobileZoomImg.removeEventListener('touchmove', mobileZoomImg._swipeTouchMove);
    mobileZoomImg.removeEventListener('touchend', mobileZoomImg._swipeTouchEnd);
    mobileZoomImg.removeEventListener('gestureend', mobileZoomImg._gestureEnd);
    mobileZoomImg.removeEventListener('click', mobileZoomImg._clickHandler);
  }
  
  // Добавляем обработчик на весь экран для перехвата жеста "назад"
  if (mobileZoomModal) {
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    
    mobileZoomModal._backGestureTouchStart = (e) => {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
      }
    };
    
    mobileZoomModal._backGestureTouchEnd = (e) => {
      if (e.changedTouches.length === 1) {
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const touchEndTime = Date.now();
        
        const deltaX = touchEndX - touchStartX; // Обратное направление для жеста "назад"
        const deltaY = Math.abs(touchEndY - touchStartY);
        const deltaTime = touchEndTime - touchStartTime;
        
        // Проверяем, не находимся ли мы в зум состоянии
        const mobileZoomImg = document.getElementById('mobileZoomImg');
        if (mobileZoomImg) {
          const transform = window.getComputedStyle(mobileZoomImg).transform;
          const matrix = new DOMMatrix(transform);
          const currentScale = matrix.a;
          
          // Если изображение увеличено - НЕ закрываем модалку жестом "назад"
          if (currentScale > 1.1) {
            return;
          }
        }
        
        // Жест "назад" в Safari: свайп справа налево с левого края экрана
        if (deltaX > 100 && deltaTime > 300 && deltaY < 50 && touchStartX < 50) {
          closeMobileZoom();
          return;
        }
      }
    };
    
    mobileZoomModal.addEventListener('touchstart', mobileZoomModal._backGestureTouchStart, { passive: true });
    mobileZoomModal.addEventListener('touchend', mobileZoomModal._backGestureTouchEnd, { passive: false });
  }
  
  if (mobileZoomImg) {
    // УМНАЯ ЛОГИКА ЗУМА: Различаем состояния зума
    if (current && current.images.length > 1) {
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartTime = 0;
      let isSwiping = false;
      let isZoomed = false; // Флаг для отслеживания состояния зума
      
      // Функция для проверки состояния зума
      const checkZoomState = () => {
        const transform = window.getComputedStyle(mobileZoomImg).transform;
        const matrix = new DOMMatrix(transform);
        const currentScale = matrix.a;
        return currentScale > 1.1; // Считаем зумом если масштаб больше 1.1
      };
      
      mobileZoomImg._swipeTouchStart = (e) => {
        if (e.touches.length === 1) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          touchStartTime = Date.now();
          isSwiping = false;
          isZoomed = checkZoomState(); // Проверяем состояние зума в начале касания
        }
      };
      
      mobileZoomImg._swipeTouchMove = (e) => {
        if (e.touches.length === 1) {
          const currentX = e.touches[0].clientX;
          const currentY = e.touches[0].clientY;
          const deltaX = Math.abs(currentX - touchStartX);
          const deltaY = Math.abs(currentY - touchStartY);
          
          // Если НЕ в зуме - определяем горизонтальный свайп для листания
          if (!isZoomed && deltaX > 10 && deltaX > deltaY) {
            isSwiping = true;
          }
        }
      };
      
      // Обработчик для сброса положения при слишком далеком отдалении
      mobileZoomImg._gestureEnd = (e) => {
        const transform = window.getComputedStyle(mobileZoomImg).transform;
        const matrix = new DOMMatrix(transform);
        const currentScale = matrix.a;
        
        // Если масштаб меньше 0.5 (слишком далеко отдалили), сбрасываем положение
        if (currentScale < 0.5) {
          mobileZoomImg.style.transform = 'scale(1) translate(0, 0)';
          mobileZoomImg.style.transformOrigin = 'center center';
          isZoomed = false;
          // НЕ закрываем модалку при отдалении!
        }
      };
      
      // Клик для выхода из зума (если увеличен) или закрытия модалки (если не увеличен)
      mobileZoomImg._clickHandler = (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        // Проверяем текущее состояние зума
        const transform = window.getComputedStyle(mobileZoomImg).transform;
        const matrix = new DOMMatrix(transform);
        const currentScale = matrix.a;
        const isCurrentlyZoomed = currentScale > 1.1;
        
        if (isCurrentlyZoomed) {
          // Если увеличен - возвращаем к нормальному размеру
          mobileZoomImg.style.transform = 'scale(1) translate(0, 0)';
          mobileZoomImg.style.transformOrigin = 'center center';
          isZoomed = false;
        } else {
          // Если не увеличен - закрываем модалку
          closeMobileZoom();
        }
      };
      
      mobileZoomImg._swipeTouchEnd = (e) => {
        // Проверяем текущее состояние зума перед обработкой свайпа
        const transform = window.getComputedStyle(mobileZoomImg).transform;
        const matrix = new DOMMatrix(transform);
        const currentScale = matrix.a;
        const isCurrentlyZoomed = currentScale > 1.1;
        
        // Если НЕ в зуме и это свайп - листаем изображения
        if (e.changedTouches.length === 1 && isSwiping && !isCurrentlyZoomed) {
          const touchEndX = e.changedTouches[0].clientX;
          const touchEndY = e.changedTouches[0].clientY;
          const touchEndTime = Date.now();
          
          const deltaX = touchStartX - touchEndX;
          const deltaY = Math.abs(touchEndY - touchStartY);
          const deltaTime = touchEndTime - touchStartTime;
          
          // Проверяем условия для свайпа
          if (Math.abs(deltaX) > 50 && deltaTime < 500 && deltaY < 100) {
            const oldIndex = curIndex;
            
            if (deltaX > 0) {
              // Свайп влево - следующее изображение
              curIndex = (curIndex + 1) % current.images.length;
            } else {
              // Свайп вправо - предыдущее изображение
              curIndex = (curIndex - 1 + current.images.length) % current.images.length;
            }
            
            // Синхронизируем изображения в обеих модалках
            const mobileMainImg = document.getElementById('mobileMainImg');
            if (mobileMainImg) {
              mobileMainImg.src = `img/${current.images[curIndex]}`;
            }
            mobileZoomImg.src = `img/${current.images[curIndex]}`;
            
            // Сбрасываем трансформацию при смене изображения
            mobileZoomImg.style.transform = 'scale(1) translate(0, 0)';
            mobileZoomImg.style.transformOrigin = 'center center';
            isZoomed = false;
            
            // Обновляем счетчик изображений
            updateMobileImageCounter();
            updateZoomDots();
            

          }
        }
      };
      
      // Добавляем все обработчики
      mobileZoomImg.addEventListener('touchstart', mobileZoomImg._swipeTouchStart, { passive: true });
      mobileZoomImg.addEventListener('touchmove', mobileZoomImg._swipeTouchMove, { passive: true });
      mobileZoomImg.addEventListener('touchend', mobileZoomImg._swipeTouchEnd, { passive: false });
      mobileZoomImg.addEventListener('gestureend', mobileZoomImg._gestureEnd, { passive: true });
      mobileZoomImg.addEventListener('click', mobileZoomImg._clickHandler);
    }
  }
  

}

// Обработчик изменения размера окна
window.addEventListener('resize', () => {
  // Закрываем все модалки при изменении размера
  closeModal();
  closeMobileModal();
  closeMobileZoom();
  
  // Обновляем видимость кнопки руководства
  const careBtn = document.getElementById('careBtn');
  const carePanel = document.getElementById('carePanel');
  
  if (careBtn && carePanel) {
    if (currentTab === 'nessffo' && window.innerWidth > 768) {
      careBtn.style.display = 'flex';
    } else {
      careBtn.style.display = 'none';
      carePanel.classList.remove('open');
    }
  }
});

// Функция для обработки скролла и фиксации навигации
function initScrollHandler() {
    const topnav = document.querySelector('.topnav');
  
  if (!topnav) {
    console.error('Topnav element not found!');
    return;
  }
  
  function handleScroll() {
    if (window.scrollY > 8) {
        topnav.classList.add('scrolled');
      } else {
        topnav.classList.remove('scrolled');
      }
    }
  
  // Добавляем обработчик скролла
  window.addEventListener('scroll', handleScroll, { passive: true });
  
  // Вызываем сразу для правильного состояния
  handleScroll();
}

// Функция для настройки обработчиков десктопной модалки
function setupDesktopModalHandlers() {
  const modalLeft = document.getElementById('modalLeft');
  const zoomBtn = document.getElementById('zoomBtn');
  
  // Обработчик клика по основному фото для листания
  if (modalLeft) {
    modalLeft.removeEventListener('click', handleDesktopViewerClick);
    modalLeft.addEventListener('click', handleDesktopViewerClick);
  }
  
  // Обработчик кнопки увеличения
  if (zoomBtn) {
    zoomBtn.removeEventListener('click', handleDesktopZoom);
    zoomBtn.addEventListener('click', handleDesktopZoom);
    
    // Добавляем дополнительные обработчики для отладки
    zoomBtn.addEventListener('mousedown', (e) => {
    });
    
    zoomBtn.addEventListener('mouseup', (e) => {
    });
    
  } else {
    console.error('zoomBtn not found!');
  }
}

// Обработчик клика по основному фото в десктопной версии
function handleDesktopViewerClick(e) {
  if (!current || current.images.length <= 1) return;
  
  // Игнорируем клик по кнопке увеличения
  if (e.target.closest('.zoom-btn')) return;
  
  const modalLeft = e.currentTarget;
  
  // Если в режиме увеличения
  if (modalLeft.classList.contains('zoomed')) {
    // Проверяем, был ли клик по краям экрана для перелистывания
    const windowWidth = window.innerWidth;
    const clickX = e.clientX;
    
    // Если клик в левой четверти экрана - предыдущее фото
    if (clickX < windowWidth / 4) {
      curIndex = (curIndex - 1 + current.images.length) % current.images.length;
      setMainImage(current.images[curIndex]);
      updateThumbnails();
      return;
    }
    // Если клик в правой четверти экрана - следующее фото
    else if (clickX > (windowWidth * 3) / 4) {
      curIndex = (curIndex + 1) % current.images.length;
      setMainImage(current.images[curIndex]);
      updateThumbnails();
      return;
    }
    // Если клик в центре - выходим из режима увеличения
    else {
      handleDesktopZoom();
      return;
    }
  }
  
  // Обычный режим (не увеличенный)
  const rect = modalLeft.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const width = rect.width;
  
  // Если клик в левой трети - предыдущее фото
  if (x < width / 3) {
    curIndex = (curIndex - 1 + current.images.length) % current.images.length;
    setMainImage(current.images[curIndex]);
    updateThumbnails();
  }
  // Если клик в правой трети - следующее фото
  else if (x > (width * 2) / 3) {
    curIndex = (curIndex + 1) % current.images.length;
    setMainImage(current.images[curIndex]);
    updateThumbnails();
  }
}

// Обработчик увеличения в десктопной версии
function handleDesktopZoom() {
  if (!current) {
    return;
  }
  
  // Простое увеличение изображения в том же модальном окне
  const mainImg = document.getElementById('viewerImg');
  const modalLeft = document.getElementById('modalLeft');
  const zoomBtn = document.getElementById('zoomBtn');
  
  if (mainImg && modalLeft) {
    // Переключаем режим увеличения
    if (modalLeft.classList.contains('zoomed')) {
      // Возвращаем к нормальному размеру
      modalLeft.classList.remove('zoomed');
      zoomBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
          <line x1="11" y1="8" x2="11" y2="14"></line>
          <line x1="8" y1="11" x2="14" y2="11"></line>
        </svg>
      `;
      
      // Удаляем обработчик ESC
      document.removeEventListener('keydown', handleEscKey);
      
    } else {
      // Включаем увеличение
      modalLeft.classList.add('zoomed');
      zoomBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      `;
      
      // Добавляем обработчик ESC
      document.addEventListener('keydown', handleEscKey);
      
    }
  } else {
    console.error('Failed to find image elements');
  }
}

// Обработчик клавиши ESC
function handleEscKey(e) {
  if (e.key === 'Escape') {
    const modalLeft = document.getElementById('modalLeft');
    const zoomBtn = document.getElementById('zoomBtn');
    
    if (modalLeft && modalLeft.classList.contains('zoomed')) {
      modalLeft.classList.remove('zoomed');
      zoomBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
          <line x1="11" y1="8" x2="11" y2="14"></line>
          <line x1="8" y1="11" x2="14" y2="11"></line>
        </svg>
      `;
      
      // Удаляем обработчик ESC
      document.removeEventListener('keydown', handleEscKey);
      
    }
  }
}

function closeAllModals() {
  const mobileModal = document.getElementById('mobileModal');
  const mobileZoomModal = document.getElementById('mobileZoomModal');
  
  if (mobileModal) {
    mobileModal.classList.remove('open');
  }
  
  if (mobileZoomModal) {
    mobileZoomModal.classList.remove('open');
    // Сбрасываем состояние зума
    const mobileZoomImg = document.getElementById('mobileZoomImg');
    if (mobileZoomImg) {
      mobileZoomImg.style.transform = 'scale(1) translate(0, 0)';
      mobileZoomImg.style.transformOrigin = 'center center';
    }
  }
  
  document.body.style.overflow = '';
  document.body.classList.remove('modal-open'); // Полностью разблокируем каталог
  
  // Сбрасываем все состояния
  isSwiping = false;
  isZoomed = false;
  isDraggingModal = false;
  
  // Восстанавливаем позицию скролла мгновенно БЕЗ АНИМАЦИИ
  if (scrollPosition > 0) {
    // Отключаем плавный скролл на время восстановления
    const originalScrollBehavior = document.documentElement.style.scrollBehavior;
    document.documentElement.style.scrollBehavior = 'auto';
    document.body.style.scrollBehavior = 'auto';
    
    // Мгновенное восстановление позиции
    window.scrollTo(0, scrollPosition);
    
    // Возвращаем плавный скролл
    document.documentElement.style.scrollBehavior = originalScrollBehavior;
    document.body.style.scrollBehavior = originalScrollBehavior;
    
    scrollPosition = 0; // Сбрасываем сохраненную позицию
  }
  
  removeMobileEventHandlers();
}

// Функция для определения зума через viewport и другие способы (поддержка старых Android)
function isImageZoomed(element) {
  // Способ 1: Через viewport scale (только для новых браузеров)
  let viewportScale = 1;
  if (window.visualViewport) {
    viewportScale = window.visualViewport.scale;
  } else {
    // Fallback для старых Android - проверяем через screen.width
    const screenRatio = window.screen.width / window.innerWidth;
    viewportScale = screenRatio;
  }
  
  // Способ 2: Через размеры изображения
  const naturalWidth = element.naturalWidth;
  const naturalHeight = element.naturalHeight;
  const displayWidth = element.offsetWidth;
  const displayHeight = element.offsetHeight;
  
  // Проверяем, что изображение загружено
  if (naturalWidth > 0 && naturalHeight > 0) {
    const scaleByWidth = displayWidth / naturalWidth;
    const scaleByHeight = displayHeight / naturalHeight;
    const scaleBySize = Math.max(scaleByWidth, scaleByHeight);
    
    // Если изображение увеличено относительно контейнера
    if (scaleBySize > 1.1) {
      return true;
    }
  }
  
  // Способ 3: Через viewport scale
  if (viewportScale > 1.01) {
    return true;
  }
  
  // Способ 4: Через CSS transform scale
  const transform = window.getComputedStyle(element).transform;
  if (transform && transform !== 'none' && transform !== 'matrix(1, 0, 0, 1, 0, 0)') {
    return true;
  }
  
  return false;
}

